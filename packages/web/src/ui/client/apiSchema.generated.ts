/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/v2/user": {
    get: operations["getInfo_2"];
  };
  "/v2/projects/namespaces/{id}": {
    put: operations["update_2"];
  };
  "/v2/projects/keys/{id}/disabled-languages": {
    get: operations["getDisabledLanguages_1"];
    put: operations["setDisabledLanguages_1"];
  };
  "/v2/projects/keys/{id}/complex-update": {
    put: operations["complexEdit_1"];
  };
  "/v2/projects/keys/{id}": {
    put: operations["edit_1"];
  };
  "/v2/projects/keys/{keyId}/tags": {
    put: operations["tagKey_1"];
  };
  "/v2/projects/import/result/languages/{languageId}/translations/{translationId}/resolve/set-override": {
    /** Resolves translation conflict. The old translation will be overridden. */
    put: operations["resolveTranslationSetOverride_1"];
  };
  "/v2/projects/import/result/languages/{languageId}/translations/{translationId}/resolve/set-keep-existing": {
    /** Resolves translation conflict. The old translation will be kept. */
    put: operations["resolveTranslationSetKeepExisting_1"];
  };
  "/v2/projects/import/result/languages/{languageId}/resolve-all/set-override": {
    /** Resolves all translation conflicts for provided language. The old translations will be overridden. */
    put: operations["resolveTranslationSetOverride_3"];
  };
  "/v2/projects/import/result/languages/{languageId}/resolve-all/set-keep-existing": {
    /** Resolves all translation conflicts for provided language. The old translations will be kept. */
    put: operations["resolveTranslationSetKeepExisting_3"];
  };
  "/v2/projects/import/result/languages/{importLanguageId}/select-existing/{existingLanguageId}": {
    /** Sets existing language to pair with language to import. Data will be imported to selected existing language when applied. */
    put: operations["selectExistingLanguage_1"];
  };
  "/v2/projects/import/result/languages/{importLanguageId}/reset-existing": {
    /** Resets existing language paired with language to import. */
    put: operations["resetExistingLanguage_1"];
  };
  "/v2/projects/import/result/files/{fileId}/select-namespace": {
    /** Sets namespace for file to import. */
    put: operations["selectNamespace_1"];
  };
  "/v2/projects/import/apply": {
    /** Imports the data prepared in previous step */
    put: operations["applyImport_1"];
  };
  "/v2/projects/batch-jobs/{id}/cancel": {
    put: operations["cancel_1"];
  };
  "/v2/projects/translations/{translationId}/set-state/{state}": {
    put: operations["setTranslationState_1"];
  };
  "/v2/projects/translations/{translationId}/comments/{commentId}/set-state/{state}": {
    put: operations["setState_1"];
  };
  "/v2/projects/translations/{translationId}/comments/{commentId}": {
    get: operations["get_10"];
    put: operations["update_6"];
    delete: operations["delete_9"];
  };
  "/v2/projects/translations/{translationId}/set-outdated-flag/{state}": {
    put: operations["setOutdated_1"];
  };
  "/v2/projects/translations/{translationId}/dismiss-auto-translated-state": {
    put: operations["dismissAutoTranslatedState_1"];
  };
  "/v2/projects/translations": {
    get: operations["getTranslations_1"];
    put: operations["setTranslations_1"];
    post: operations["createOrUpdateTranslations_1"];
  };
  "/v2/projects/languages/{languageId}": {
    get: operations["get_12"];
    put: operations["editLanguage_1"];
    delete: operations["deleteLanguage_3"];
  };
  "/v2/projects/keys/{keyId}/auto-translate": {
    /**
     * Uses enabled auto-translation methods.
     * You need to set at least one of useMachineTranslation or useTranslationMemory to true.
     *
     * This will replace the the existing translation with the result obtained from specified source!
     */
    put: operations["autoTranslate_1"];
  };
  "/v2/organizations/{id}": {
    get: operations["get_15"];
  };
  "/v2/projects": {
    get: operations["getAll"];
    post: operations["createProject"];
  };
  "/v2/projects/keys/info": {
    post: operations["getInfo_1"];
  };
  "/v2/projects/keys/import-resolvable": {
    post: operations["importKeys_1"];
  };
  "/v2/projects/keys/import": {
    post: operations["importKeys_3"];
  };
  "/v2/projects/keys/create": {
    post: operations["create_3"];
  };
  "/v2/projects/keys": {
    get: operations["getAll_2"];
    post: operations["create_4"];
    delete: operations["delete_5"];
  };
  "/v2/projects/start-batch-job/untag-keys": {
    post: operations["untagKeys_1"];
  };
  "/v2/projects/start-batch-job/tag-keys": {
    post: operations["tagKeys_1"];
  };
  "/v2/projects/start-batch-job/set-translation-state": {
    post: operations["setTranslationState_3"];
  };
  "/v2/projects/start-batch-job/set-keys-namespace": {
    post: operations["setKeysNamespace_1"];
  };
  "/v2/projects/start-batch-job/pre-translate-by-tm": {
    /** Pre-translate provided keys to provided languages by TM. */
    post: operations["translate_1"];
  };
  "/v2/projects/start-batch-job/machine-translate": {
    /** Translate provided keys to provided languages through primary MT provider. */
    post: operations["machineTranslation_1"];
  };
  "/v2/projects/start-batch-job/delete-keys": {
    post: operations["deleteKeys_1"];
  };
  "/v2/projects/start-batch-job/copy-translations": {
    /** Copy translation values from one language to other languages. */
    post: operations["copyTranslations_1"];
  };
  "/v2/projects/start-batch-job/clear-translations": {
    /** Clear translation values for provided keys in selected languages. */
    post: operations["clearTranslations_1"];
  };
  "/v2/projects/import": {
    /** Prepares provided files to import. */
    post: operations["addFiles_1"];
    /** Deletes prepared import data. */
    delete: operations["cancelImport_1"];
  };
  "/v2/projects/export": {
    get: operations["export_1"];
    post: operations["exportPost_1"];
  };
  "/v2/projects/big-meta": {
    post: operations["store_1"];
  };
  "/v2/projects/translations/{translationId}/comments": {
    get: operations["getAll_6"];
    post: operations["create_8"];
  };
  "/v2/projects/translations/create-comment": {
    post: operations["create_10"];
  };
  "/v2/projects/suggest/translation-memory": {
    post: operations["suggestTranslationMemory_1"];
  };
  "/v2/projects/suggest/machine-translations-streaming": {
    post: operations["suggestMachineTranslationsStreaming_1"];
  };
  "/v2/projects/suggest/machine-translations": {
    post: operations["suggestMachineTranslations_1"];
  };
  "/v2/projects/languages": {
    get: operations["getAll_8"];
    post: operations["createLanguage_1"];
  };
  "/v2/projects/keys/{keyId}/screenshots": {
    get: operations["getKeyScreenshots"];
    post: operations["uploadScreenshot"];
  };
  "/v2/organizations": {
    get: operations["getAll_10"];
    post: operations["create_12"];
  };
  "/v2/image-upload": {
    post: operations["upload"];
  };
  "/v2/projects/used-namespaces": {
    get: operations["getUsedNamespaces_1"];
  };
  "/v2/projects/namespaces": {
    get: operations["getAllNamespaces_1"];
  };
  "/v2/projects/namespace-by-name/{name}": {
    get: operations["getByName_1"];
  };
  "/v2/projects/keys/search": {
    get: operations["searchForKey_1"];
  };
  "/v2/projects/activity": {
    get: operations["getActivity_1"];
  };
  "/v2/projects/tags": {
    get: operations["getAll_4"];
  };
  "/v2/projects/my-batch-jobs": {
    get: operations["myList_1"];
  };
  "/v2/projects/keys/{id}/big-meta": {
    get: operations["getBigMeta_1"];
  };
  "/v2/projects/import/result/languages/{languageId}/translations": {
    /** Returns translations prepared to import. */
    get: operations["getImportTranslations_1"];
  };
  "/v2/projects/import/result/languages/{languageId}": {
    /** Returns language prepared to import. */
    get: operations["getImportLanguage_1"];
    /** Deletes language prepared to import. */
    delete: operations["deleteLanguage_1"];
  };
  "/v2/projects/import/result/files/{importFileId}/issues": {
    /** Returns issues for uploaded file. */
    get: operations["getImportFileIssues_1"];
  };
  "/v2/projects/import/result": {
    /** Returns the result of preparation. */
    get: operations["getImportResult_1"];
  };
  "/v2/projects/import/all-namespaces": {
    /** Returns all existing and imported namespaces */
    get: operations["getAllNamespaces_3"];
  };
  "/v2/projects/current-batch-jobs": {
    /** Completed batch operations are returned only if they are not older than 1 hour. If user doesn't have permission to view all batch operations, only their operations are returned. */
    get: operations["currentJobs_1"];
  };
  "/v2/projects/batch-jobs/{id}": {
    get: operations["get_8"];
  };
  "/v2/projects/batch-jobs": {
    get: operations["list_4"];
  };
  "/v2/projects/translations/{translationId}/history": {
    get: operations["getTranslationHistory_1"];
  };
  "/v2/projects/translations/{languages}": {
    get: operations["getAllTranslations_1"];
  };
  "/v2/projects/translations/select-all": {
    get: operations["getSelectAllKeyIds_1"];
  };
  "/v2/projects/stats/daily-activity": {
    get: operations["getProjectDailyActivity_1"];
  };
  "/v2/projects/stats": {
    get: operations["getProjectStats_1"];
  };
  "/v2/pats/current": {
    get: operations["getCurrent"];
  };
  "/v2/organizations/{slug}": {
    get: operations["get_14"];
  };
  "/v2/organizations/{organizationId}/machine-translation-credit-balance": {
    get: operations["getOrganizationCredits"];
  };
  "/v2/api-keys/current": {
    get: operations["getCurrent_1"];
  };
  "/v2/api-keys/current-permissions": {
    get: operations["getCurrentPermissions"];
  };
  "/api/project/export/jsonZip": {
    get: operations["doExportJsonZip_1"];
  };
  "/v2/projects/keys/{ids}": {
    delete: operations["delete_3"];
  };
  "/v2/projects/keys/{keyId}/tags/{tagId}": {
    delete: operations["removeTag_1"];
  };
  "/v2/projects/keys/{keyId}/screenshots/{ids}": {
    delete: operations["deleteScreenshots"];
  };
  "/v2/image-upload/{ids}": {
    delete: operations["delete_12"];
  };
}

export interface components {
  schemas: {
    UserUpdateRequestDto: {
      name: string;
      email: string;
      currentPassword?: string;
      /** @description Callback url for link sent in e-mail. This may be omitted, when server has set frontEndUrl in properties. */
      callbackUrl?: string;
    };
    Avatar: {
      large: string;
      thumbnail: string;
    };
    Links: { [key: string]: components["schemas"]["Link"] };
    PrivateUserAccountModel: {
      /** Format: int64 */
      id: number;
      username: string;
      name?: string;
      emailAwaitingVerification?: string;
      mfaEnabled: boolean;
      avatar?: components["schemas"]["Avatar"];
      accountType: "LOCAL" | "MANAGED" | "THIRD_PARTY";
      globalServerRole: "USER" | "ADMIN";
      deletable: boolean;
      needsSuperJwtToken: boolean;
    };
    UserUpdatePasswordRequestDto: {
      currentPassword: string;
      password: string;
    };
    JwtAuthenticationResponse: {
      accessToken?: string;
      tokenType?: string;
    };
    UserTotpEnableRequestDto: {
      totpKey: string;
      otp: string;
      password: string;
    };
    UserMfaRecoveryRequestDto: {
      password: string;
    };
    QuickStartModel: {
      finished: boolean;
      completedSteps: string[];
      open: boolean;
    };
    EditProjectDTO: {
      name: string;
      slug?: string;
      /** Format: int64 */
      baseLanguageId?: number;
      description?: string;
    };
    ComputedPermissionModel: {
      permissionModel?: components["schemas"]["PermissionModel"];
      origin:
        | "ORGANIZATION_BASE"
        | "DIRECT"
        | "ORGANIZATION_OWNER"
        | "NONE"
        | "SERVER_ADMIN";
      /** @description The user's permission type. This field is null if uses granular permissions */
      type?: "NONE" | "VIEW" | "TRANSLATE" | "REVIEW" | "EDIT" | "MANAGE";
      /**
       * @deprecated
       * @description Deprecated (use translateLanguageIds).
       *
       * List of languages current user has TRANSLATE permission to. If null, all languages edition is permitted.
       * @example 200001,200004
       */
      permittedLanguageIds?: number[];
      /**
       * @description List of languages user can translate to. If null, all languages editing is permitted.
       * @example 200001,200004
       */
      translateLanguageIds?: number[];
      /**
       * @description List of languages user can view. If null, all languages view is permitted.
       * @example 200001,200004
       */
      viewLanguageIds?: number[];
      /**
       * @description List of languages user can change state to. If null, changing state of all language values is permitted.
       * @example 200001,200004
       */
      stateChangeLanguageIds?: number[];
      /**
       * @description Granted scopes to the user. When user has type permissions, this field contains permission scopes of the type.
       * @example KEYS_EDIT,TRANSLATIONS_VIEW
       */
      scopes: (
        | "translations.view"
        | "translations.edit"
        | "keys.edit"
        | "screenshots.upload"
        | "screenshots.delete"
        | "screenshots.view"
        | "activity.view"
        | "languages.edit"
        | "admin"
        | "project.edit"
        | "members.view"
        | "members.edit"
        | "translation-comments.add"
        | "translation-comments.edit"
        | "translation-comments.set-state"
        | "translations.state-edit"
        | "keys.view"
        | "keys.delete"
        | "keys.create"
        | "batch-jobs.view"
        | "batch-jobs.cancel"
        | "translations.batch-by-tm"
        | "translations.batch-machine"
        | "content-delivery.manage"
        | "content-delivery.publish"
        | "webhooks.manage"
      )[];
    };
    LanguageModel: {
      /** Format: int64 */
      id: number;
      /**
       * @description Language name in english
       * @example Czech
       */
      name: string;
      /**
       * @description Language tag according to BCP 47 definition
       * @example cs-CZ
       */
      tag: string;
      /**
       * @description Language name in this language
       * @example čeština
       */
      originalName?: string;
      /**
       * @description Language flag emoji as UTF-8 emoji
       * @example 🇨🇿
       */
      flagEmoji?: string;
      /** @description Whether is base language of project */
      base: boolean;
    };
    /**
     * @description Current user's direct permission
     * @example MANAGE
     */
    PermissionModel: {
      /**
       * @description Granted scopes to the user. When user has type permissions, this field contains permission scopes of the type.
       * @example KEYS_EDIT,TRANSLATIONS_VIEW
       */
      scopes: (
        | "translations.view"
        | "translations.edit"
        | "keys.edit"
        | "screenshots.upload"
        | "screenshots.delete"
        | "screenshots.view"
        | "activity.view"
        | "languages.edit"
        | "admin"
        | "project.edit"
        | "members.view"
        | "members.edit"
        | "translation-comments.add"
        | "translation-comments.edit"
        | "translation-comments.set-state"
        | "translations.state-edit"
        | "keys.view"
        | "keys.delete"
        | "keys.create"
        | "batch-jobs.view"
        | "batch-jobs.cancel"
        | "translations.batch-by-tm"
        | "translations.batch-machine"
        | "content-delivery.manage"
        | "content-delivery.publish"
        | "webhooks.manage"
      )[];
      /** @description The user's permission type. This field is null if uses granular permissions */
      type?: "NONE" | "VIEW" | "TRANSLATE" | "REVIEW" | "EDIT" | "MANAGE";
      /**
       * @deprecated
       * @description Deprecated (use translateLanguageIds).
       *
       * List of languages current user has TRANSLATE permission to. If null, all languages edition is permitted.
       * @example 200001,200004
       */
      permittedLanguageIds?: number[];
      /**
       * @description List of languages user can translate to. If null, all languages editing is permitted.
       * @example 200001,200004
       */
      translateLanguageIds?: number[];
      /**
       * @description List of languages user can view. If null, all languages view is permitted.
       * @example 200001,200004
       */
      viewLanguageIds?: number[];
      /**
       * @description List of languages user can change state to. If null, changing state of all language values is permitted.
       * @example 200001,200004
       */
      stateChangeLanguageIds?: number[];
    };
    ProjectModel: {
      /** Format: int64 */
      id: number;
      name: string;
      description?: string;
      slug?: string;
      avatar?: components["schemas"]["Avatar"];
      organizationOwner?: components["schemas"]["SimpleOrganizationModel"];
      baseLanguage?: components["schemas"]["LanguageModel"];
      organizationRole?: "MEMBER" | "OWNER";
      directPermission?: components["schemas"]["PermissionModel"];
      computedPermission: components["schemas"]["ComputedPermissionModel"];
    };
    SimpleOrganizationModel: {
      /** Format: int64 */
      id: number;
      /** @example Beautiful organization */
      name: string;
      /** @example btforg */
      slug: string;
      /** @example This is a beautiful organization full of beautiful and clever people */
      description?: string;
      basePermissions: components["schemas"]["PermissionModel"];
      avatar?: components["schemas"]["Avatar"];
    };
    WebhookConfigRequest: {
      url: string;
    };
    WebhookConfigModel: {
      /** Format: int64 */
      id: number;
      url: string;
      webhookSecret: string;
      /**
       * Format: int64
       * @description Date of the first failed webhook request. If the last webhook request is successful, this value is set to null.
       */
      firstFailed?: number;
      /**
       * Format: int64
       * @description Date of the last webhook request.
       */
      lastExecuted?: number;
    };
    AutoTranslationSettingsDto: {
      /** Format: int64 */
      languageId?: number;
      /** @description If true, new keys will be automatically translated via batch operation using translation memory when 100% match is found */
      usingTranslationMemory: boolean;
      /** @description If true, new keys will be automatically translated via batch operationusing primary machine translation service.When "usingTranslationMemory" is enabled, it tries to translate it with translation memory first. */
      usingMachineTranslation: boolean;
      /**
       * @description If true, import will trigger batch operation to translate the new new keys.
       * It includes also the data imported via CLI, Figma, or other integrations using batch key import.
       */
      enableForImport: boolean;
    };
    AutoTranslationConfigModel: {
      /** Format: int64 */
      languageId?: number;
      /** @description If true, new keys will be automatically translated via batch operation using translation memory when 100% match is found */
      usingTranslationMemory: boolean;
      /** @description If true, new keys will be automatically translated via batch operationusing primary machine translation service.When "usingTranslationMemory" is enabled, it tries to translate it with translation memory first. */
      usingMachineTranslation: boolean;
      /**
       * @description If true, import will trigger batch operation to translate the new new keys.
       * It includes also the data imported via CLI, Figma, or other integrations using batch key import.
       */
      enableForImport: boolean;
    };
    CollectionModelAutoTranslationConfigModel: {
      _embedded?: {
        configs?: components["schemas"]["AutoTranslationConfigModel"][];
      };
    };
    UpdateNamespaceDto: {
      name: string;
    };
    NamespaceModel: {
      /**
       * Format: int64
       * @description The id of namespace
       * @example 10000048
       */
      id: number;
      /** @example homepage */
      name: string;
    };
    MachineTranslationLanguagePropsDto: {
      /**
       * Format: int64
       * @description The language to apply those rules. If null, then this settings are default.
       */
      targetLanguageId?: number;
      /**
       * @deprecated
       * @description This service will be used for automated translation
       */
      primaryService?:
        | "GOOGLE"
        | "AWS"
        | "DEEPL"
        | "AZURE"
        | "BAIDU"
        | "TOLGEE";
      primaryServiceInfo?: components["schemas"]["MtServiceInfo"];
      /**
       * @deprecated
       * @description List of enabled services (deprecated: use enabledServicesInfo)
       */
      enabledServices?: (
        | "GOOGLE"
        | "AWS"
        | "DEEPL"
        | "AZURE"
        | "BAIDU"
        | "TOLGEE"
      )[];
      /** @description Info about enabled services */
      enabledServicesInfo?: components["schemas"]["MtServiceInfo"][];
    };
    /** @description Info about enabled services */
    MtServiceInfo: {
      serviceType: "GOOGLE" | "AWS" | "DEEPL" | "AZURE" | "BAIDU" | "TOLGEE";
      formality?: "FORMAL" | "INFORMAL" | "DEFAULT";
    };
    SetMachineTranslationSettingsDto: {
      settings: components["schemas"]["MachineTranslationLanguagePropsDto"][];
    };
    CollectionModelLanguageConfigItemModel: {
      _embedded?: {
        languageConfigs?: components["schemas"]["LanguageConfigItemModel"][];
      };
    };
    LanguageConfigItemModel: {
      /**
       * Format: int64
       * @description When null, its a default configuration applied to not configured languages
       */
      targetLanguageId?: number;
      /** @description When null, its a default configuration applied to not configured languages */
      targetLanguageTag?: string;
      /** @description When null, its a default configuration applied to not configured languages */
      targetLanguageName?: string;
      /**
       * @deprecated
       * @description Service used for automated translating (deprecated: use primaryServiceInfo)
       */
      primaryService?:
        | "GOOGLE"
        | "AWS"
        | "DEEPL"
        | "AZURE"
        | "BAIDU"
        | "TOLGEE";
      primaryServiceInfo?: components["schemas"]["MtServiceInfo"];
      /**
       * @deprecated
       * @description Services to be used for suggesting (deprecated: use enabledServicesInfo)
       */
      enabledServices: (
        | "GOOGLE"
        | "AWS"
        | "DEEPL"
        | "AZURE"
        | "BAIDU"
        | "TOLGEE"
      )[];
      /** @description Info about enabled services */
      enabledServicesInfo: components["schemas"]["MtServiceInfo"][];
    };
    SetDisabledLanguagesRequest: {
      languageIds: number[];
    };
    CollectionModelLanguageModel: {
      _embedded?: {
        languages?: components["schemas"]["LanguageModel"][];
      };
    };
    ComplexEditKeyDto: {
      /** @description Name of the key */
      name: string;
      namespace?: string;
      /** @description Translations to update */
      translations?: { [key: string]: string };
      /** @description Translation states to update, if not provided states won't be modified */
      states?: { [key: string]: "TRANSLATED" | "REVIEWED" };
      /** @description Tags of the key. If not provided tags won't be modified */
      tags?: string[];
      /** @description IDs of screenshots to delete */
      screenshotIdsToDelete?: number[];
      /** @description Ids of screenshots uploaded with /v2/image-upload endpoint */
      screenshotUploadedImageIds?: number[];
      screenshotsToAdd?: components["schemas"]["KeyScreenshotDto"][];
      /** @description Keys in the document used as a context for machine translation. Keys in the same order as they appear in the document. The order is important! We are using it for graph distance calculation. */
      relatedKeysInOrder?: components["schemas"]["RelatedKeyDto"][];
    };
    KeyInScreenshotPositionDto: {
      /** Format: int32 */
      x: number;
      /** Format: int32 */
      y: number;
      /** Format: int32 */
      width: number;
      /** Format: int32 */
      height: number;
    };
    KeyScreenshotDto: {
      text?: string;
      /**
       * Format: int64
       * @description Ids of screenshot uploaded with /v2/image-upload endpoint
       */
      uploadedImageId: number;
      positions?: components["schemas"]["KeyInScreenshotPositionDto"][];
    };
    /** @description Keys in the document used as a context for machine translation. Keys in the same order as they appear in the document. The order is important! We are using it for graph distance calculation. */
    RelatedKeyDto: {
      namespace?: string;
      keyName: string;
    };
    KeyInScreenshotModel: {
      /** Format: int64 */
      keyId: number;
      position?: components["schemas"]["KeyInScreenshotPosition"];
      keyName: string;
      keyNamespace?: string;
      originalText?: string;
    };
    KeyInScreenshotPosition: {
      /** Format: int32 */
      x: number;
      /** Format: int32 */
      y: number;
      /** Format: int32 */
      width: number;
      /** Format: int32 */
      height: number;
    };
    KeyWithDataModel: {
      /**
       * Format: int64
       * @description Id of key record
       */
      id: number;
      /**
       * @description Name of key
       * @example this_is_super_key
       */
      name: string;
      /**
       * @description Namespace of key
       * @example homepage
       */
      namespace?: string;
      /**
       * @description Translations object containing values updated in this request
       * @example [object Object]
       */
      translations: {
        [key: string]: components["schemas"]["TranslationModel"];
      };
      /** @description Tags of key */
      tags: components["schemas"]["TagModel"][];
      /** @description Screenshots of the key */
      screenshots: components["schemas"]["ScreenshotModel"][];
    };
    /** @description Screenshots of the key */
    ScreenshotModel: {
      /** Format: int64 */
      id: number;
      /**
       * @description File name, which may be downloaded from the screenshot path.
       *
       * When images are secured. Encrypted timestamp is appended to the filename.
       */
      filename: string;
      /**
       * @description Thumbnail file name, which may be downloaded from the screenshot path.
       *
       * When images are secured. Encrypted timestamp is appended to the filename.
       */
      thumbnail: string;
      fileUrl: string;
      thumbnailUrl: string;
      /** Format: date-time */
      createdAt?: string;
      keyReferences: components["schemas"]["KeyInScreenshotModel"][];
      location?: string;
      /** Format: int32 */
      width?: number;
      /** Format: int32 */
      height?: number;
    };
    /** @description Tags of key */
    TagModel: {
      /** Format: int64 */
      id: number;
      name: string;
    };
    /**
     * @description Translations object containing values updated in this request
     * @example [object Object]
     */
    TranslationModel: {
      /**
       * Format: int64
       * @description Id of translation record
       */
      id: number;
      /** @description Translation text */
      text?: string;
      /** @description State of translation */
      state: "UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED";
      /** @description Whether base language translation was changed after this translation was updated */
      outdated: boolean;
      /** @description Was translated using Translation Memory or Machine translation service? */
      auto: boolean;
      /** @description Which machine translation service was used to auto translate this */
      mtProvider?: "GOOGLE" | "AWS" | "DEEPL" | "AZURE" | "BAIDU" | "TOLGEE";
    };
    EditKeyDto: {
      name: string;
      namespace?: string;
    };
    KeyModel: {
      /**
       * Format: int64
       * @description Id of key record
       */
      id: number;
      /**
       * @description Name of key
       * @example this_is_super_key
       */
      name: string;
      /**
       * @description Namespace of key
       * @example homepage
       */
      namespace?: string;
    };
    ProjectInviteUserDto: {
      type?: "NONE" | "VIEW" | "TRANSLATE" | "REVIEW" | "EDIT" | "MANAGE";
      /**
       * @description Granted scopes for the invited user
       * @example translations.view,translations.edit
       */
      scopes?: string[];
      /**
       * @deprecated
       * @description Deprecated -> use translate languages
       */
      languages?: number[];
      /**
       * @deprecated
       * @description Languages user can translate to
       */
      translateLanguages?: number[];
      /**
       * @deprecated
       * @description Languages user can view
       */
      viewLanguages?: number[];
      /**
       * @deprecated
       * @description Languages user can change translation state (review)
       */
      stateChangeLanguages?: number[];
      /** @description Email to send invitation to */
      email?: string;
      /** @description Name of invited user */
      name?: string;
    };
    ProjectInvitationModel: {
      /** Format: int64 */
      id: number;
      code: string;
      type?: "NONE" | "VIEW" | "TRANSLATE" | "REVIEW" | "EDIT" | "MANAGE";
      permittedLanguageIds?: number[];
      /** Format: date-time */
      createdAt: string;
      invitedUserName?: string;
      invitedUserEmail?: string;
      permission: components["schemas"]["PermissionModel"];
    };
    AzureContentStorageConfigDto: {
      connectionString?: string;
      containerName: string;
    };
    ContentStorageRequest: {
      name: string;
      azureContentStorageConfig?: components["schemas"]["AzureContentStorageConfigDto"];
      s3ContentStorageConfig?: components["schemas"]["S3ContentStorageConfigDto"];
      publicUrlPrefix?: string;
    };
    S3ContentStorageConfigDto: {
      bucketName: string;
      accessKey: string;
      secretKey: string;
      endpoint: string;
      signingRegion: string;
      contentStorageType?: "S3" | "AZURE";
      enabled?: boolean;
    };
    AzureContentStorageConfigModel: {
      containerName?: string;
    };
    ContentStorageModel: {
      /** Format: int64 */
      id: number;
      name: string;
      publicUrlPrefix?: string;
      azureContentStorageConfig?: components["schemas"]["AzureContentStorageConfigModel"];
      s3ContentStorageConfig?: components["schemas"]["S3ContentStorageConfigModel"];
    };
    S3ContentStorageConfigModel: {
      bucketName: string;
      endpoint: string;
      signingRegion: string;
    };
    ContentDeliveryConfigRequest: {
      name: string;
      /**
       * Format: int64
       * @description Id of custom storage to use for content delivery. If null, default server storage is used. Tolgee Cloud provides default Content Storage.
       */
      contentStorageId?: number;
      /** @description If true, data are published to the content delivery automatically after each change. */
      autoPublish: boolean;
      /**
       * @description Languages to be contained in export.
       *
       * If null, all languages are exported
       * @example en
       */
      languages?: string[];
      /** @description Format to export to */
      format: "JSON" | "XLIFF";
      /**
       * @description Delimiter to structure file content.
       *
       * e.g. For key "home.header.title" would result in {"home": {"header": "title": {"Hello"}}} structure.
       *
       * When null, resulting file won't be structured.
       */
      structureDelimiter?: string;
      /** @description Filter key IDs to be contained in export */
      filterKeyId?: number[];
      /** @description Filter key IDs not to be contained in export */
      filterKeyIdNot?: number[];
      /** @description Filter keys tagged by */
      filterTag?: string;
      /** @description Filter keys with prefix */
      filterKeyPrefix?: string;
      /** @description Filter translations with state. By default, everything except untranslated is exported. */
      filterState?: ("UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED")[];
      /** @description Select one ore multiple namespaces to export */
      filterNamespace?: string[];
    };
    ContentDeliveryConfigModel: {
      /** Format: int64 */
      id: number;
      name: string;
      slug: string;
      storage?: components["schemas"]["ContentStorageModel"];
      publicUrl?: string;
      autoPublish: boolean;
      /** Format: int64 */
      lastPublished?: number;
      /**
       * @description Languages to be contained in export.
       *
       * If null, all languages are exported
       * @example en
       */
      languages?: string[];
      /** @description Format to export to */
      format: "JSON" | "XLIFF";
      /**
       * @description Delimiter to structure file content.
       *
       * e.g. For key "home.header.title" would result in {"home": {"header": "title": {"Hello"}}} structure.
       *
       * When null, resulting file won't be structured.
       */
      structureDelimiter?: string;
      /** @description Filter key IDs to be contained in export */
      filterKeyId?: number[];
      /** @description Filter key IDs not to be contained in export */
      filterKeyIdNot?: number[];
      /** @description Filter keys tagged by */
      filterTag?: string;
      /** @description Filter keys with prefix */
      filterKeyPrefix?: string;
      /** @description Filter translations with state. By default, everything except untranslated is exported. */
      filterState?: ("UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED")[];
      /** @description Select one ore multiple namespaces to export */
      filterNamespace?: string[];
    };
    TagKeyDto: {
      name: string;
    };
    SetFileNamespaceRequest: {
      namespace?: string;
    };
    /** @description User who created the comment */
    SimpleUserAccountModel: {
      /** Format: int64 */
      id: number;
      username: string;
      name?: string;
      avatar?: components["schemas"]["Avatar"];
      deleted: boolean;
    };
    TranslationCommentModel: {
      /**
       * Format: int64
       * @description Id of translation comment record
       */
      id: number;
      /** @description Text of comment */
      text: string;
      /** @description State of translation */
      state: "RESOLUTION_NOT_NEEDED" | "NEEDS_RESOLUTION" | "RESOLVED";
      author: components["schemas"]["SimpleUserAccountModel"];
      /**
       * Format: date-time
       * @description Date when it was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Date when it was updated
       */
      updatedAt: string;
    };
    TranslationCommentDto: {
      text: string;
      state: "RESOLUTION_NOT_NEEDED" | "NEEDS_RESOLUTION" | "RESOLVED";
    };
    SetTranslationsWithKeyDto: {
      /**
       * @description Key name to set translations for
       * @example what_a_key_to_translate
       */
      key: string;
      /** @description The namespace of the key. (When empty or null default namespace will be used) */
      namespace?: string;
      /**
       * @description Object mapping language tag to translation
       * @example [object Object]
       */
      translations: { [key: string]: string };
      /**
       * @description List of languages to return translations for.
       *
       * If not provided, only modified translation will be provided.
       *
       * @example en,de,fr
       */
      languagesToReturn?: string[];
    };
    SetTranslationsResponseModel: {
      /**
       * Format: int64
       * @description Id of key record
       */
      keyId: number;
      /**
       * @description Name of key
       * @example this_is_super_key
       */
      keyName: string;
      /**
       * @description The namespace of the key
       * @example homepage
       */
      keyNamespace?: string;
      /**
       * @description Translations object containing values updated in this request
       * @example [object Object]
       */
      translations: {
        [key: string]: components["schemas"]["TranslationModel"];
      };
    };
    LanguageDto: {
      /**
       * @description Language name in english
       * @example Czech
       */
      name: string;
      /**
       * @description Language name in this language
       * @example čeština
       */
      originalName: string;
      /**
       * @description Language tag according to BCP 47 definition
       * @example cs-CZ
       */
      tag: string;
      /**
       * @description Language flag emoji as UTF-8 emoji
       * @example 🇨🇿
       */
      flagEmoji?: string;
    };
    UpdatePatDto: {
      /** @description New description of the PAT */
      description: string;
    };
    PatModel: {
      /** Format: int64 */
      id: number;
      description: string;
      /** Format: int64 */
      expiresAt?: number;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
      /** Format: int64 */
      lastUsedAt?: number;
    };
    RegeneratePatDto: {
      /**
       * Format: int64
       * @description Expiration date in epoch format (milliseconds). When null key never expires.
       * @example 1661172869000
       */
      expiresAt?: number;
    };
    RevealedPatModel: {
      token: string;
      /** Format: int64 */
      id: number;
      description: string;
      /** Format: int64 */
      lastUsedAt?: number;
      /** Format: int64 */
      expiresAt?: number;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
    };
    SetOrganizationRoleDto: {
      roleType: "MEMBER" | "OWNER";
    };
    OrganizationDto: {
      /** @example Beautiful organization */
      name: string;
      /** @example This is a beautiful organization full of beautiful and clever people */
      description?: string;
      /** @example btforg */
      slug?: string;
    };
    OrganizationModel: {
      /** Format: int64 */
      id: number;
      /** @example Beautiful organization */
      name: string;
      /** @example btforg */
      slug: string;
      /** @example This is a beautiful organization full of beautiful and clever people */
      description?: string;
      basePermissions: components["schemas"]["PermissionModel"];
      /**
       * @description The role of currently authorized user.
       *
       * Can be null when user has direct access to one of the projects owned by the organization.
       */
      currentUserRole?: "MEMBER" | "OWNER";
      avatar?: components["schemas"]["Avatar"];
    };
    OrganizationInviteUserDto: {
      roleType: "MEMBER" | "OWNER";
      /** @description Name of invited user */
      name?: string;
      /** @description Email to send invitation to */
      email?: string;
    };
    OrganizationInvitationModel: {
      /** Format: int64 */
      id: number;
      code: string;
      type: "MEMBER" | "OWNER";
      /** Format: date-time */
      createdAt: string;
      invitedUserName?: string;
      invitedUserEmail?: string;
    };
    SetLicenseKeyDto: {
      licenseKey: string;
    };
    EeSubscriptionModel: {
      name: string;
      licenseKey: string;
      enabledFeatures: (
        | "GRANULAR_PERMISSIONS"
        | "PRIORITIZED_FEATURE_REQUESTS"
        | "PREMIUM_SUPPORT"
        | "DEDICATED_SLACK_CHANNEL"
        | "ASSISTED_UPDATES"
        | "DEPLOYMENT_ASSISTANCE"
        | "BACKUP_CONFIGURATION"
        | "TEAM_TRAINING"
        | "ACCOUNT_MANAGER"
        | "STANDARD_SUPPORT"
        | "PROJECT_LEVEL_CONTENT_STORAGES"
        | "WEBHOOKS"
        | "MULTIPLE_CONTENT_DELIVERY_CONFIGS"
      )[];
      /** Format: int64 */
      currentPeriodEnd?: number;
      cancelAtPeriodEnd: boolean;
      /** Format: int64 */
      currentUserCount: number;
      status:
        | "ACTIVE"
        | "CANCELED"
        | "PAST_DUE"
        | "UNPAID"
        | "ERROR"
        | "KEY_USED_BY_ANOTHER_INSTANCE";
      /** Format: date-time */
      lastValidCheck?: string;
    };
    V2EditApiKeyDto: {
      scopes: string[];
      description?: string;
    };
    ApiKeyModel: {
      /**
       * Format: int64
       * @description ID of the API key
       */
      id: number;
      /** @description Description */
      description: string;
      /** @description Username of user owner */
      username?: string;
      /** @description Full name of user owner */
      userFullName?: string;
      /**
       * Format: int64
       * @description Api key's project ID
       */
      projectId: number;
      /** @description Api key's project name */
      projectName: string;
      /**
       * Format: int64
       * @description Timestamp of API key expiraion
       */
      expiresAt?: number;
      /**
       * Format: int64
       * @description Timestamp of API key last usage
       */
      lastUsedAt?: number;
      /**
       * @description Api key's permission scopes
       * @example screenshots.upload,screenshots.delete,translations.edit,screenshots.view,translations.view,keys.edit
       */
      scopes: string[];
    };
    RegenerateApiKeyDto: {
      /**
       * Format: int64
       * @description Expiration date in epoch format (milliseconds). When null key never expires.
       * @example 1661172869000
       */
      expiresAt?: number;
    };
    RevealedApiKeyModel: {
      /** @description Resulting user's api key */
      key: string;
      /** Format: int64 */
      id: number;
      projectName: string;
      userFullName?: string;
      username?: string;
      description: string;
      /** Format: int64 */
      lastUsedAt?: number;
      /** Format: int64 */
      expiresAt?: number;
      /** Format: int64 */
      projectId: number;
      scopes: string[];
    };
    SuperTokenRequest: {
      /** @description Has to be provided when TOTP enabled */
      otp?: string;
      /** @description Has to be provided when TOTP not enabled */
      password?: string;
    };
    GenerateSlugDto: {
      name: string;
      oldSlug?: string;
    };
    BusinessEventReportRequest: {
      eventName: string;
      anonymousUserId?: string;
      /** Format: int64 */
      organizationId?: number;
      /** Format: int64 */
      projectId?: number;
      data?: { [key: string]: { [key: string]: unknown } };
    };
    IdentifyRequest: {
      anonymousUserId: string;
    };
    CreateProjectDTO: {
      name: string;
      languages: components["schemas"]["LanguageDto"][];
      /** @description Slug of your project used in url e.g. "/v2/projects/what-a-project". If not provided, it will be generated */
      slug?: string;
      /**
       * Format: int64
       * @description Organization to create the project in
       */
      organizationId: number;
      /** @description Tag of one of created languages, to select it as base language. If not provided, first language will be selected as base. */
      baseLanguageTag?: string;
    };
    WebhookTestResponse: {
      success: boolean;
    };
    GetKeysRequestDto: {
      keys: components["schemas"]["KeyDefinitionDto"][];
      /** @description Tags to return language translations in */
      languageTags: string[];
    };
    KeyDefinitionDto: {
      name: string;
      namespace?: string;
    };
    CollectionModelKeyWithDataModel: {
      _embedded?: {
        keys?: components["schemas"]["KeyWithDataModel"][];
      };
    };
    ImportKeysResolvableDto: {
      keys: components["schemas"]["ImportKeysResolvableItemDto"][];
    };
    ImportKeysResolvableItemDto: {
      /**
       * @description Key name to set translations for
       * @example what_a_key_to_translate
       */
      name: string;
      /** @description The namespace of the key. (When empty or null default namespace will be used) */
      namespace?: string;
      screenshots?: components["schemas"]["KeyScreenshotDto"][];
      /** @description Object mapping language tag to translation */
      translations: {
        [key: string]: components["schemas"]["ImportTranslationResolvableDto"];
      };
    };
    /** @description Object mapping language tag to translation */
    ImportTranslationResolvableDto: {
      /**
       * @description Translation text
       * @example Hello! I am a translation!
       */
      text: string;
      /**
       * @description Determines, how conflict is resolved.
       *
       * - KEEP: Translation is not changed
       * - OVERRIDE: Translation is overridden
       * - NEW: New translation is created)
       *
       * @example OVERRIDE
       */
      resolution: "KEEP" | "OVERRIDE" | "NEW";
    };
    KeyImportResolvableResultModel: {
      /** @description List of keys */
      keys: components["schemas"]["KeyModel"][];
      /** @description Map uploadedImageId to screenshot */
      screenshots: { [key: string]: components["schemas"]["ScreenshotModel"] };
    };
    ImportKeysDto: {
      keys: components["schemas"]["ImportKeysItemDto"][];
    };
    ImportKeysItemDto: {
      /**
       * @description Key name to set translations for
       * @example what_a_key_to_translate
       */
      name: string;
      /** @description The namespace of the key. (When empty or null default namespace will be used) */
      namespace?: string;
      /**
       * @description Object mapping language tag to translation
       * @example [object Object]
       */
      translations: { [key: string]: string };
      /**
       * @description Tags of the key
       * @example homepage,user-profile
       */
      tags?: string[];
    };
    CreateKeyDto: {
      /** @description Name of the key */
      name: string;
      namespace?: string;
      translations?: { [key: string]: string };
      /** @description Translation states to update, if not provided states won't be modified */
      states?: { [key: string]: "TRANSLATED" | "REVIEWED" };
      tags?: string[];
      /** @description Ids of screenshots uploaded with /v2/image-upload endpoint */
      screenshotUploadedImageIds?: number[];
      screenshots?: components["schemas"]["KeyScreenshotDto"][];
      /** @description Keys in the document used as a context for machine translation. Keys in the same order as they appear in the document. The order is important! We are using it for graph distance calculation. */
      relatedKeysInOrder?: components["schemas"]["RelatedKeyDto"][];
    };
    StorageTestResult: {
      success: boolean;
      message?:
        | "UNAUTHENTICATED"
        | "API_ACCESS_FORBIDDEN"
        | "API_KEY_NOT_FOUND"
        | "INVALID_API_KEY"
        | "INVALID_PROJECT_API_KEY"
        | "PROJECT_API_KEY_EXPIRED"
        | "BAD_CREDENTIALS"
        | "MFA_ENABLED"
        | "INVALID_OTP_CODE"
        | "MFA_NOT_ENABLED"
        | "CAN_NOT_REVOKE_OWN_PERMISSIONS"
        | "DATA_CORRUPTED"
        | "INVITATION_CODE_DOES_NOT_EXIST_OR_EXPIRED"
        | "LANGUAGE_TAG_EXISTS"
        | "LANGUAGE_NAME_EXISTS"
        | "LANGUAGE_NOT_FOUND"
        | "OPERATION_NOT_PERMITTED"
        | "REGISTRATIONS_NOT_ALLOWED"
        | "PROJECT_NOT_FOUND"
        | "RESOURCE_NOT_FOUND"
        | "SCOPE_NOT_FOUND"
        | "KEY_EXISTS"
        | "THIRD_PARTY_AUTH_ERROR_MESSAGE"
        | "THIRD_PARTY_AUTH_NO_EMAIL"
        | "THIRD_PARTY_AUTH_NO_SUB"
        | "THIRD_PARTY_AUTH_UNKNOWN_ERROR"
        | "THIRD_PARTY_UNAUTHORIZED"
        | "THIRD_PARTY_GOOGLE_WORKSPACE_MISMATCH"
        | "USERNAME_ALREADY_EXISTS"
        | "USERNAME_OR_PASSWORD_INVALID"
        | "USER_ALREADY_HAS_PERMISSIONS"
        | "USER_ALREADY_HAS_ROLE"
        | "USER_NOT_FOUND"
        | "FILE_NOT_IMAGE"
        | "FILE_TOO_BIG"
        | "INVALID_TIMESTAMP"
        | "EMAIL_NOT_VERIFIED"
        | "MISSING_CALLBACK_URL"
        | "INVALID_JWT_TOKEN"
        | "EXPIRED_JWT_TOKEN"
        | "GENERAL_JWT_ERROR"
        | "CANNOT_FIND_SUITABLE_ADDRESS_PART"
        | "ADDRESS_PART_NOT_UNIQUE"
        | "USER_IS_NOT_MEMBER_OF_ORGANIZATION"
        | "ORGANIZATION_HAS_NO_OTHER_OWNER"
        | "USER_HAS_NO_PROJECT_ACCESS"
        | "USER_IS_ORGANIZATION_OWNER"
        | "CANNOT_SET_YOUR_OWN_PERMISSIONS"
        | "USER_IS_ORGANIZATION_MEMBER"
        | "PROPERTY_NOT_MUTABLE"
        | "IMPORT_LANGUAGE_NOT_FROM_PROJECT"
        | "EXISTING_LANGUAGE_NOT_SELECTED"
        | "CONFLICT_IS_NOT_RESOLVED"
        | "LANGUAGE_ALREADY_SELECTED"
        | "CANNOT_PARSE_FILE"
        | "COULD_NOT_RESOLVE_PROPERTY"
        | "CANNOT_ADD_MORE_THEN_100_LANGUAGES"
        | "NO_LANGUAGES_PROVIDED"
        | "LANGUAGE_WITH_BASE_LANGUAGE_TAG_NOT_FOUND"
        | "LANGUAGE_NOT_FROM_PROJECT"
        | "CANNOT_DELETE_BASE_LANGUAGE"
        | "KEY_NOT_FROM_PROJECT"
        | "MAX_SCREENSHOTS_EXCEEDED"
        | "TRANSLATION_NOT_FROM_PROJECT"
        | "CAN_EDIT_ONLY_OWN_COMMENT"
        | "REQUEST_PARSE_ERROR"
        | "FILTER_BY_VALUE_STATE_NOT_VALID"
        | "IMPORT_HAS_EXPIRED"
        | "TAG_NOT_FROM_PROJECT"
        | "TRANSLATION_TEXT_TOO_LONG"
        | "INVALID_RECAPTCHA_TOKEN"
        | "CANNOT_LEAVE_OWNING_PROJECT"
        | "CANNOT_LEAVE_PROJECT_WITH_ORGANIZATION_ROLE"
        | "DONT_HAVE_DIRECT_PERMISSIONS"
        | "TAG_TOO_LOG"
        | "TOO_MANY_UPLOADED_IMAGES"
        | "ONE_OR_MORE_IMAGES_NOT_FOUND"
        | "SCREENSHOT_NOT_OF_KEY"
        | "SERVICE_NOT_FOUND"
        | "TOO_MANY_REQUESTS"
        | "TRANSLATION_NOT_FOUND"
        | "OUT_OF_CREDITS"
        | "KEY_NOT_FOUND"
        | "ORGANIZATION_NOT_FOUND"
        | "CANNOT_FIND_BASE_LANGUAGE"
        | "BASE_LANGUAGE_NOT_FOUND"
        | "NO_EXPORTED_RESULT"
        | "MULTIPLE_FILES_MUST_BE_ZIPPED"
        | "CANNOT_SET_YOUR_OWN_ROLE"
        | "ONLY_TRANSLATE_REVIEW_OR_VIEW_PERMISSION_ACCEPTS_VIEW_LANGUAGES"
        | "OAUTH2_TOKEN_URL_NOT_SET"
        | "OAUTH2_USER_URL_NOT_SET"
        | "EMAIL_ALREADY_INVITED_OR_MEMBER"
        | "PRICE_NOT_FOUND"
        | "INVOICE_NOT_FROM_ORGANIZATION"
        | "INVOICE_NOT_FOUND"
        | "PLAN_NOT_FOUND"
        | "PLAN_NOT_AVAILABLE_ANY_MORE"
        | "NO_AUTO_TRANSLATION_METHOD"
        | "CANNOT_TRANSLATE_BASE_LANGUAGE"
        | "PAT_NOT_FOUND"
        | "INVALID_PAT"
        | "PAT_EXPIRED"
        | "OPERATION_UNAVAILABLE_FOR_ACCOUNT_TYPE"
        | "VALIDATION_EMAIL_IS_NOT_VALID"
        | "CURRENT_PASSWORD_REQUIRED"
        | "CANNOT_CREATE_ORGANIZATION"
        | "WRONG_CURRENT_PASSWORD"
        | "WRONG_PARAM_TYPE"
        | "EXPIRED_SUPER_JWT_TOKEN"
        | "CANNOT_DELETE_YOUR_OWN_ACCOUNT"
        | "CANNOT_SORT_BY_THIS_COLUMN"
        | "NAMESPACE_NOT_FOUND"
        | "NAMESPACE_EXISTS"
        | "INVALID_AUTHENTICATION_METHOD"
        | "UNKNOWN_SORT_PROPERTY"
        | "ONLY_REVIEW_PERMISSION_ACCEPTS_STATE_CHANGE_LANGUAGES"
        | "ONLY_TRANSLATE_OR_REVIEW_PERMISSION_ACCEPTS_TRANSLATE_LANGUAGES"
        | "CANNOT_SET_LANGUAGE_PERMISSIONS_FOR_ADMIN_SCOPE"
        | "CANNOT_SET_VIEW_LANGUAGES_WITHOUT_TRANSLATIONS_VIEW_SCOPE"
        | "CANNOT_SET_TRANSLATE_LANGUAGES_WITHOUT_TRANSLATIONS_EDIT_SCOPE"
        | "CANNOT_SET_STATE_CHANGE_LANGUAGES_WITHOUT_TRANSLATIONS_STATE_EDIT_SCOPE"
        | "LANGUAGE_NOT_PERMITTED"
        | "SCOPES_HAS_TO_BE_SET"
        | "SET_EXACTLY_ONE_OF_SCOPES_OR_TYPE"
        | "TRANSLATION_EXISTS"
        | "IMPORT_KEYS_ERROR"
        | "PROVIDE_ONLY_ONE_OF_SCREENSHOTS_AND_SCREENSHOT_UPLOADED_IMAGE_IDS"
        | "MULTIPLE_PROJECTS_NOT_SUPPORTED"
        | "PLAN_TRANSLATION_LIMIT_EXCEEDED"
        | "FEATURE_NOT_ENABLED"
        | "LICENSE_KEY_NOT_FOUND"
        | "CANNOT_SET_VIEW_LANGUAGES_WITHOUT_FOR_LEVEL_BASED_PERMISSIONS"
        | "CANNOT_SET_DIFFERENT_TRANSLATE_AND_STATE_CHANGE_LANGUAGES_FOR_LEVEL_BASED_PERMISSIONS"
        | "CANNOT_DISABLE_YOUR_OWN_ACCOUNT"
        | "SUBSCRIPTION_NOT_FOUND"
        | "INVOICE_DOES_NOT_HAVE_USAGE"
        | "CUSTOMER_NOT_FOUND"
        | "SUBSCRIPTION_NOT_ACTIVE"
        | "ORGANIZATION_ALREADY_SUBSCRIBED"
        | "ORGANIZATION_NOT_SUBSCRIBED"
        | "LICENSE_KEY_USED_BY_ANOTHER_INSTANCE"
        | "TRANSLATION_SPENDING_LIMIT_EXCEEDED"
        | "CREDIT_SPENDING_LIMIT_EXCEEDED"
        | "SEATS_SPENDING_LIMIT_EXCEEDED"
        | "THIS_INSTANCE_IS_ALREADY_LICENSED"
        | "BIG_META_NOT_FROM_PROJECT"
        | "MT_SERVICE_NOT_ENABLED"
        | "PROJECT_NOT_SELECTED"
        | "ORGANIZATION_NOT_SELECTED"
        | "PLAN_HAS_SUBSCRIBERS"
        | "TRANSLATION_FAILED"
        | "BATCH_JOB_NOT_FOUND"
        | "KEY_EXISTS_IN_NAMESPACE"
        | "TAG_IS_BLANK"
        | "EXECUTION_FAILED_ON_MANAGEMENT_ERROR"
        | "TRANSLATION_API_RATE_LIMIT"
        | "CANNOT_FINALIZE_ACTIVITY"
        | "FORMALITY_NOT_SUPPORTED_BY_SERVICE"
        | "LANGUAGE_NOT_SUPPORTED_BY_SERVICE"
        | "RATE_LIMITED"
        | "PAT_ACCESS_NOT_ALLOWED"
        | "PAK_ACCESS_NOT_ALLOWED"
        | "CANNOT_MODIFY_DISABLED_TRANSLATION"
        | "AZURE_CONFIG_REQUIRED"
        | "S3_CONFIG_REQUIRED"
        | "CONTENT_STORAGE_CONFIG_REQUIRED"
        | "CONTENT_STORAGE_TEST_FAILED"
        | "CONTENT_STORAGE_CONFIG_INVALID"
        | "INVALID_CONNECTION_STRING"
        | "CANNOT_CREATE_AZURE_STORAGE_CLIENT"
        | "S3_ACCESS_KEY_REQUIRED"
        | "AZURE_CONNECTION_STRING_REQUIRED"
        | "S3_SECRET_KEY_REQUIRED"
        | "CANNOT_STORE_FILE_TO_CONTENT_STORAGE"
        | "UNEXPECTED_ERROR_WHILE_PUBLISHING_TO_CONTENT_STORAGE"
        | "WEBHOOK_RESPONDED_WITH_NON_200_STATUS"
        | "UNEXPECTED_ERROR_WHILE_EXECUTING_WEBHOOK"
        | "CONTENT_STORAGE_IS_IN_USE"
        | "CANNOT_SET_STATE_FOR_MISSING_TRANSLATION"
        | "NO_PROJECT_ID_PROVIDED";
      params?: { [key: string]: unknown }[];
    };
    UntagKeysRequest: {
      keyIds: number[];
      tags: string[];
    };
    BatchJobModel: {
      /**
       * Format: int64
       * @description Batch job id
       */
      id: number;
      /** @description Status of the batch job */
      status:
        | "PENDING"
        | "RUNNING"
        | "SUCCESS"
        | "FAILED"
        | "CANCELLED"
        | "DEBOUNCED";
      /** @description Type of the batch job */
      type:
        | "PRE_TRANSLATE_BT_TM"
        | "MACHINE_TRANSLATE"
        | "AUTO_TRANSLATE"
        | "DELETE_KEYS"
        | "SET_TRANSLATIONS_STATE"
        | "CLEAR_TRANSLATIONS"
        | "COPY_TRANSLATIONS"
        | "TAG_KEYS"
        | "UNTAG_KEYS"
        | "SET_KEYS_NAMESPACE"
        | "AUTOMATION";
      /**
       * Format: int32
       * @description Total items, that have been processed so far
       */
      progress: number;
      /**
       * Format: int32
       * @description Total items
       */
      totalItems: number;
      author?: components["schemas"]["SimpleUserAccountModel"];
      /**
       * Format: int64
       * @description The time when the job created
       */
      createdAt: number;
      /**
       * Format: int64
       * @description The time when the job was last updated (status change)
       */
      updatedAt: number;
      /**
       * Format: int64
       * @description The activity revision id, that stores the activity details of the job
       */
      activityRevisionId?: number;
      /** @description If the job failed, this is the error message */
      errorMessage?: string;
    };
    TagKeysRequest: {
      keyIds: number[];
      tags: string[];
    };
    SetTranslationsStateStateRequest: {
      keyIds: number[];
      languageIds: number[];
      state: "UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED";
    };
    SetKeysNamespaceRequest: {
      keyIds: number[];
      namespace?: string;
    };
    PreTranslationByTmRequest: {
      keyIds: number[];
      targetLanguageIds: number[];
    };
    MachineTranslationRequest: {
      keyIds: number[];
      targetLanguageIds: number[];
    };
    DeleteKeysRequest: {
      keyIds: number[];
    };
    CopyTranslationRequest: {
      keyIds: number[];
      /** Format: int64 */
      sourceLanguageId: number;
      targetLanguageIds: number[];
    };
    ClearTranslationsRequest: {
      keyIds: number[];
      languageIds: number[];
    };
    ErrorResponseBody: {
      code: string;
      params?: { [key: string]: unknown }[];
    };
    ImportAddFilesResultModel: {
      errors: components["schemas"]["ErrorResponseBody"][];
      result?: components["schemas"]["PagedModelImportLanguageModel"];
    };
    ImportLanguageModel: {
      /** Format: int64 */
      id: number;
      name: string;
      /** Format: int64 */
      existingLanguageId?: number;
      existingLanguageTag?: string;
      existingLanguageAbbreviation?: string;
      existingLanguageName?: string;
      importFileName: string;
      /** Format: int64 */
      importFileId: number;
      /** Format: int32 */
      importFileIssueCount: number;
      namespace?: string;
      /** Format: int32 */
      totalCount: number;
      /** Format: int32 */
      conflictCount: number;
      /** Format: int32 */
      resolvedCount: number;
    };
    PageMetadata: {
      /** Format: int64 */
      size?: number;
      /** Format: int64 */
      totalElements?: number;
      /** Format: int64 */
      totalPages?: number;
      /** Format: int64 */
      number?: number;
    };
    PagedModelImportLanguageModel: {
      _embedded?: {
        languages?: components["schemas"]["ImportLanguageModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    ExportParams: {
      /**
       * @description Languages to be contained in export.
       *
       * If null, all languages are exported
       * @example en
       */
      languages?: string[];
      /** @description Format to export to */
      format: "JSON" | "XLIFF";
      /**
       * @description Delimiter to structure file content.
       *
       * e.g. For key "home.header.title" would result in {"home": {"header": "title": {"Hello"}}} structure.
       *
       * When null, resulting file won't be structured.
       */
      structureDelimiter?: string;
      /** @description Filter key IDs to be contained in export */
      filterKeyId?: number[];
      /** @description Filter key IDs not to be contained in export */
      filterKeyIdNot?: number[];
      /** @description Filter keys tagged by */
      filterTag?: string;
      /** @description Filter keys with prefix */
      filterKeyPrefix?: string;
      /** @description Filter translations with state. By default, everything except untranslated is exported. */
      filterState?: ("UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED")[];
      /** @description Select one ore multiple namespaces to export */
      filterNamespace?: string[];
      zip: boolean;
    };
    StreamingResponseBody: { [key: string]: unknown };
    BigMetaDto: {
      /** @description Keys in the document used as a context for machine translation. Keys in the same order as they appear in the document. The order is important! We are using it for graph distance calculation. */
      relatedKeysInOrder?: components["schemas"]["RelatedKeyDto"][];
    };
    TranslationCommentWithLangKeyDto: {
      /** Format: int64 */
      keyId: number;
      /** Format: int64 */
      languageId: number;
      text: string;
      state: "RESOLUTION_NOT_NEEDED" | "NEEDS_RESOLUTION" | "RESOLVED";
    };
    TranslationWithCommentModel: {
      translation: components["schemas"]["TranslationModel"];
      comment: components["schemas"]["TranslationCommentModel"];
    };
    SuggestRequestDto: {
      /**
       * Format: int64
       * @description Key Id to get results for. Use when key is stored already.
       */
      keyId: number;
      /** Format: int64 */
      targetLanguageId: number;
      /** @description Text value of base translation. Useful, when base translation is not stored yet. */
      baseText?: string;
      /** @description List of services to use. If null, then all enabled services are used. */
      services?: ("GOOGLE" | "AWS" | "DEEPL" | "AZURE" | "BAIDU" | "TOLGEE")[];
    };
    PagedModelTranslationMemoryItemModel: {
      _embedded?: {
        translationMemoryItems?: components["schemas"]["TranslationMemoryItemModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    TranslationMemoryItemModel: {
      targetText: string;
      baseText: string;
      keyName: string;
      /** Format: float */
      similarity: number;
    };
    SuggestResultModel: {
      /**
       * @deprecated
       * @description String translations provided by enabled services. (deprecated, use `result` instead)
       * @example
       *     {
       *       "GOOGLE": "This was translated by Google",
       *       "TOLGEE": "This was translated by Tolgee Translator",
       *     }
       */
      machineTranslations?: { [key: string]: string };
      /**
       * @description Results provided by enabled services.
       * @example [object Object]
       */
      result?: { [key: string]: components["schemas"]["TranslationItemModel"] };
      /** @description If true, the base translation was empty and no translation was provided. */
      baseBlank: boolean;
    };
    /**
     * @description Results provided by enabled services.
     * @example [object Object]
     */
    TranslationItemModel: {
      output: string;
      contextDescription?: string;
    };
    ScreenshotInfoDto: {
      text?: string;
      positions?: components["schemas"]["KeyInScreenshotPositionDto"][];
      location?: string;
    };
    CreatePatDto: {
      /** @description Description of the PAT */
      description: string;
      /**
       * Format: int64
       * @description Expiration date in epoch format (milliseconds). When null, token never expires.
       * @example 1661172869000
       */
      expiresAt?: number;
    };
    ImageUploadInfoDto: {
      location?: string;
    };
    UploadedImageModel: {
      /** Format: int64 */
      id: number;
      filename: string;
      fileUrl: string;
      requestFilename: string;
      /** Format: date-time */
      createdAt: string;
      location?: string;
    };
    AverageProportionalUsageItemModel: {
      total: number;
      unusedQuantity: number;
      usedQuantity: number;
      usedQuantityOverPlan: number;
    };
    PlanIncludedUsageModel: {
      /** Format: int64 */
      seats: number;
      /** Format: int64 */
      translationSlots: number;
      /** Format: int64 */
      translations: number;
      /** Format: int64 */
      mtCredits: number;
    };
    PlanPricesModel: {
      perSeat: number;
      perThousandTranslations?: number;
      perThousandMtCredits?: number;
      subscriptionMonthly: number;
      subscriptionYearly: number;
    };
    PrepareSetEeLicenceKeyModel: {
      plan: components["schemas"]["SelfHostedEePlanModel"];
      usage: components["schemas"]["UsageModel"];
    };
    SelfHostedEePlanModel: {
      /** Format: int64 */
      id: number;
      name: string;
      public: boolean;
      enabledFeatures: (
        | "GRANULAR_PERMISSIONS"
        | "PRIORITIZED_FEATURE_REQUESTS"
        | "PREMIUM_SUPPORT"
        | "DEDICATED_SLACK_CHANNEL"
        | "ASSISTED_UPDATES"
        | "DEPLOYMENT_ASSISTANCE"
        | "BACKUP_CONFIGURATION"
        | "TEAM_TRAINING"
        | "ACCOUNT_MANAGER"
        | "STANDARD_SUPPORT"
        | "PROJECT_LEVEL_CONTENT_STORAGES"
        | "WEBHOOKS"
        | "MULTIPLE_CONTENT_DELIVERY_CONFIGS"
      )[];
      prices: components["schemas"]["PlanPricesModel"];
      includedUsage: components["schemas"]["PlanIncludedUsageModel"];
      hasYearlyPrice: boolean;
    };
    SumUsageItemModel: {
      total: number;
      /** Format: int64 */
      unusedQuantity: number;
      /** Format: int64 */
      usedQuantity: number;
      /** Format: int64 */
      usedQuantityOverPlan: number;
    };
    UsageModel: {
      subscriptionPrice?: number;
      /** @description Relevant for invoices only. When there are applied stripe credits, we need to reduce the total price by this amount. */
      appliedStripeCredits?: number;
      seats: components["schemas"]["AverageProportionalUsageItemModel"];
      translations: components["schemas"]["AverageProportionalUsageItemModel"];
      credits?: components["schemas"]["SumUsageItemModel"];
      total: number;
    };
    CreateApiKeyDto: {
      /** Format: int64 */
      projectId: number;
      scopes: string[];
      /** @description Description of the project API key */
      description?: string;
      /**
       * Format: int64
       * @description Expiration date in epoch format (milliseconds). When null key never expires.
       * @example 1661172869000
       */
      expiresAt?: number;
    };
    TextNode: { [key: string]: unknown };
    SignUpDto: {
      name: string;
      email: string;
      organizationName?: string;
      password: string;
      invitationCode?: string;
      callbackUrl?: string;
      recaptchaToken?: string;
    };
    ResetPassword: {
      email: string;
      code: string;
      password?: string;
    };
    ResetPasswordRequest: {
      callbackUrl: string;
      email: string;
    };
    LoginRequest: {
      username: string;
      password: string;
      otp?: string;
    };
    CollectionModelSimpleOrganizationModel: {
      _embedded?: {
        organizations?: components["schemas"]["SimpleOrganizationModel"][];
      };
    };
    UserPreferencesModel: {
      language?: string;
      /** Format: int64 */
      preferredOrganizationId?: number;
    };
    HierarchyItem: {
      scope:
        | "translations.view"
        | "translations.edit"
        | "keys.edit"
        | "screenshots.upload"
        | "screenshots.delete"
        | "screenshots.view"
        | "activity.view"
        | "languages.edit"
        | "admin"
        | "project.edit"
        | "members.view"
        | "members.edit"
        | "translation-comments.add"
        | "translation-comments.edit"
        | "translation-comments.set-state"
        | "translations.state-edit"
        | "keys.view"
        | "keys.delete"
        | "keys.create"
        | "batch-jobs.view"
        | "batch-jobs.cancel"
        | "translations.batch-by-tm"
        | "translations.batch-machine"
        | "content-delivery.manage"
        | "content-delivery.publish"
        | "webhooks.manage";
      requires: components["schemas"]["HierarchyItem"][];
    };
    AnnouncementDto: {
      type:
        | "FEATURE_BATCH_OPERATIONS"
        | "FEATURE_MT_FORMALITY"
        | "FEATURE_CONTENT_DELIVERY_AND_WEBHOOKS";
    };
    AuthMethodsDTO: {
      github: components["schemas"]["OAuthPublicConfigDTO"];
      google: components["schemas"]["OAuthPublicConfigDTO"];
      oauth2: components["schemas"]["OAuthPublicExtendsConfigDTO"];
    };
    InitialDataModel: {
      serverConfiguration: components["schemas"]["PublicConfigurationDTO"];
      userInfo?: components["schemas"]["PrivateUserAccountModel"];
      preferredOrganization?: components["schemas"]["PrivateOrganizationModel"];
      languageTag?: string;
      eeSubscription?: components["schemas"]["EeSubscriptionModel"];
      announcement?: components["schemas"]["AnnouncementDto"];
    };
    MtServiceDTO: {
      enabled: boolean;
      defaultEnabledForProject: boolean;
    };
    MtServicesDTO: {
      defaultPrimaryService?:
        | "GOOGLE"
        | "AWS"
        | "DEEPL"
        | "AZURE"
        | "BAIDU"
        | "TOLGEE";
      services: { [key: string]: components["schemas"]["MtServiceDTO"] };
    };
    OAuthPublicConfigDTO: {
      clientId?: string;
      enabled: boolean;
    };
    OAuthPublicExtendsConfigDTO: {
      clientId?: string;
      authorizationUrl?: string;
      scopes?: string[];
      enabled: boolean;
    };
    PrivateOrganizationModel: {
      organizationModel?: components["schemas"]["OrganizationModel"];
      /** @example Features organization has enabled */
      enabledFeatures: (
        | "GRANULAR_PERMISSIONS"
        | "PRIORITIZED_FEATURE_REQUESTS"
        | "PREMIUM_SUPPORT"
        | "DEDICATED_SLACK_CHANNEL"
        | "ASSISTED_UPDATES"
        | "DEPLOYMENT_ASSISTANCE"
        | "BACKUP_CONFIGURATION"
        | "TEAM_TRAINING"
        | "ACCOUNT_MANAGER"
        | "STANDARD_SUPPORT"
        | "PROJECT_LEVEL_CONTENT_STORAGES"
        | "WEBHOOKS"
        | "MULTIPLE_CONTENT_DELIVERY_CONFIGS"
      )[];
      quickStart?: components["schemas"]["QuickStartModel"];
      /** @example Beautiful organization */
      name: string;
      /** Format: int64 */
      id: number;
      basePermissions: components["schemas"]["PermissionModel"];
      /** @example This is a beautiful organization full of beautiful and clever people */
      description?: string;
      /**
       * @description The role of currently authorized user.
       *
       * Can be null when user has direct access to one of the projects owned by the organization.
       */
      currentUserRole?: "MEMBER" | "OWNER";
      avatar?: components["schemas"]["Avatar"];
      /** @example btforg */
      slug: string;
    };
    PublicBillingConfigurationDTO: {
      enabled: boolean;
    };
    PublicConfigurationDTO: {
      machineTranslationServices: components["schemas"]["MtServicesDTO"];
      billing: components["schemas"]["PublicBillingConfigurationDTO"];
      version: string;
      authentication: boolean;
      authMethods?: components["schemas"]["AuthMethodsDTO"];
      passwordResettable: boolean;
      allowRegistrations: boolean;
      screenshotsUrl: string;
      /** Format: int32 */
      maxUploadFileSize: number;
      clientSentryDsn?: string;
      needsEmailVerification: boolean;
      userCanCreateOrganizations: boolean;
      appName: string;
      showVersion: boolean;
      internalControllerEnabled: boolean;
      /** Format: int64 */
      maxTranslationTextLength: number;
      recaptchaSiteKey?: string;
      chatwootToken?: string;
      capterraTracker?: string;
      ga4Tag?: string;
      postHogApiKey?: string;
      postHogHost?: string;
      contentDeliveryConfigured: boolean;
    };
    DocItem: {
      name: string;
      displayName?: string;
      description?: string;
    };
    PagedModelProjectModel: {
      _embedded?: {
        projects?: components["schemas"]["ProjectModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelWebhookConfigModel: {
      _embedded?: {
        webhookConfigs?: components["schemas"]["WebhookConfigModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelUserAccountInProjectModel: {
      _embedded?: {
        users?: components["schemas"]["UserAccountInProjectModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    UserAccountInProjectModel: {
      /** Format: int64 */
      id: number;
      username: string;
      name?: string;
      avatar?: components["schemas"]["Avatar"];
      organizationRole?: "MEMBER" | "OWNER";
      organizationBasePermission: components["schemas"]["PermissionModel"];
      directPermission?: components["schemas"]["PermissionModel"];
      computedPermission: components["schemas"]["ComputedPermissionModel"];
    };
    CollectionModelUsedNamespaceModel: {
      _embedded?: {
        namespaces?: components["schemas"]["UsedNamespaceModel"][];
      };
    };
    UsedNamespaceModel: {
      /**
       * Format: int64
       * @description The id of namespace. Null for default namespace.
       * @example 10000048
       */
      id?: number;
      /**
       * @description Name of namespace. Null if default.
       * @example homepage
       */
      name?: string;
    };
    PagedModelNamespaceModel: {
      _embedded?: {
        namespaces?: components["schemas"]["NamespaceModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CollectionModelLanguageInfoModel: {
      _embedded?: {
        languageInfos?: components["schemas"]["LanguageInfoModel"][];
      };
    };
    LanguageInfoModel: {
      /** Format: int64 */
      languageId: number;
      languageTag: string;
      supportedServices: components["schemas"]["MtSupportedService"][];
    };
    MtSupportedService: {
      serviceType: "GOOGLE" | "AWS" | "DEEPL" | "AZURE" | "BAIDU" | "TOLGEE";
      formalitySupported: boolean;
    };
    KeySearchResultView: {
      name: string;
      /** Format: int64 */
      id: number;
      namespace?: string;
      baseTranslation?: string;
      translation?: string;
    };
    KeySearchSearchResultModel: {
      view?: components["schemas"]["KeySearchResultView"];
      name: string;
      /** Format: int64 */
      id: number;
      namespace?: string;
      baseTranslation?: string;
      translation?: string;
    };
    PagedModelKeySearchSearchResultModel: {
      _embedded?: {
        keys?: components["schemas"]["KeySearchSearchResultModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelKeyModel: {
      _embedded?: {
        keys?: components["schemas"]["KeyModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelContentStorageModel: {
      _embedded?: {
        contentStorages?: components["schemas"]["ContentStorageModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelContentDeliveryConfigModel: {
      _embedded?: {
        contentDeliveryConfigs?: components["schemas"]["ContentDeliveryConfigModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CollectionModelKeyModel: {
      _embedded?: {
        keys?: components["schemas"]["KeyModel"][];
      };
    };
    EntityDescriptionWithRelations: {
      entityClass: string;
      /** Format: int64 */
      entityId: number;
      data: { [key: string]: { [key: string]: unknown } };
    };
    ExistenceEntityDescription: {
      entityClass: string;
      /** Format: int64 */
      entityId: number;
      data: { [key: string]: { [key: string]: unknown } };
      relations: {
        [key: string]: components["schemas"]["EntityDescriptionWithRelations"];
      };
      exists?: boolean;
    };
    ModifiedEntityModel: {
      /** Format: int64 */
      entityId: number;
      description?: { [key: string]: { [key: string]: unknown } };
      modifications?: {
        [key: string]: components["schemas"]["PropertyModification"];
      };
      relations?: {
        [key: string]: components["schemas"]["ExistenceEntityDescription"];
      };
      exists?: boolean;
    };
    PagedModelProjectActivityModel: {
      _embedded?: {
        activities?: components["schemas"]["ProjectActivityModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    ProjectActivityAuthorModel: {
      /** Format: int64 */
      id: number;
      username?: string;
      name?: string;
      avatar?: components["schemas"]["Avatar"];
      deleted: boolean;
    };
    ProjectActivityModel: {
      /** Format: int64 */
      revisionId: number;
      /** Format: int64 */
      timestamp: number;
      type:
        | "UNKNOWN"
        | "SET_TRANSLATION_STATE"
        | "SET_TRANSLATIONS"
        | "DISMISS_AUTO_TRANSLATED_STATE"
        | "SET_OUTDATED_FLAG"
        | "TRANSLATION_COMMENT_ADD"
        | "TRANSLATION_COMMENT_DELETE"
        | "TRANSLATION_COMMENT_EDIT"
        | "TRANSLATION_COMMENT_SET_STATE"
        | "SCREENSHOT_DELETE"
        | "SCREENSHOT_ADD"
        | "KEY_TAGS_EDIT"
        | "KEY_NAME_EDIT"
        | "KEY_DELETE"
        | "CREATE_KEY"
        | "COMPLEX_EDIT"
        | "IMPORT"
        | "CREATE_LANGUAGE"
        | "EDIT_LANGUAGE"
        | "DELETE_LANGUAGE"
        | "CREATE_PROJECT"
        | "EDIT_PROJECT"
        | "NAMESPACE_EDIT"
        | "BATCH_PRE_TRANSLATE_BY_TM"
        | "BATCH_MACHINE_TRANSLATE"
        | "AUTO_TRANSLATE"
        | "BATCH_CLEAR_TRANSLATIONS"
        | "BATCH_COPY_TRANSLATIONS"
        | "BATCH_SET_TRANSLATION_STATE"
        | "BATCH_TAG_KEYS"
        | "BATCH_UNTAG_KEYS"
        | "BATCH_SET_KEYS_NAMESPACE"
        | "AUTOMATION";
      author?: components["schemas"]["ProjectActivityAuthorModel"];
      modifiedEntities?: {
        [key: string]: components["schemas"]["ModifiedEntityModel"][];
      };
      meta?: { [key: string]: { [key: string]: unknown } };
      counts?: { [key: string]: number };
      params?: { [key: string]: unknown };
    };
    PropertyModification: {
      old?: { [key: string]: unknown };
      new?: { [key: string]: unknown };
    };
    PagedModelTagModel: {
      _embedded?: {
        tags?: components["schemas"]["TagModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelBatchJobModel: {
      _embedded?: {
        batchJobs?: components["schemas"]["BatchJobModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CreditBalanceModel: {
      /** Format: int64 */
      creditBalance: number;
      /** Format: int64 */
      bucketSize: number;
      /** Format: int64 */
      extraCreditBalance: number;
    };
    CollectionModelKeyWithBaseTranslationModel: {
      _embedded?: {
        keys?: components["schemas"]["KeyWithBaseTranslationModel"][];
      };
    };
    KeyWithBaseTranslationModel: {
      /**
       * Format: int64
       * @description Id of key record
       */
      id: number;
      /**
       * @description Name of key
       * @example this_is_super_key
       */
      name: string;
      /**
       * @description Namespace of key
       * @example homepage
       */
      namespace?: string;
      /**
       * @description Base translation
       * @example This is translation
       */
      baseTranslation?: string;
    };
    ImportTranslationModel: {
      /** Format: int64 */
      id: number;
      text?: string;
      keyName: string;
      /** Format: int64 */
      keyId: number;
      /** Format: int64 */
      conflictId?: number;
      conflictText?: string;
      override: boolean;
      resolved: boolean;
    };
    PagedModelImportTranslationModel: {
      _embedded?: {
        translations?: components["schemas"]["ImportTranslationModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    ImportFileIssueModel: {
      /** Format: int64 */
      id: number;
      type:
        | "KEY_IS_NOT_STRING"
        | "MULTIPLE_VALUES_FOR_KEY_AND_LANGUAGE"
        | "VALUE_IS_NOT_STRING"
        | "KEY_IS_EMPTY"
        | "VALUE_IS_EMPTY"
        | "PO_MSGCTXT_NOT_SUPPORTED"
        | "ID_ATTRIBUTE_NOT_PROVIDED"
        | "TARGET_NOT_PROVIDED"
        | "TRANSLATION_TOO_LONG"
        | "KEY_IS_BLANK";
      params: components["schemas"]["ImportFileIssueParamModel"][];
    };
    ImportFileIssueParamModel: {
      type:
        | "KEY_NAME"
        | "KEY_ID"
        | "LANGUAGE_ID"
        | "KEY_INDEX"
        | "VALUE"
        | "LINE"
        | "FILE_NODE_ORIGINAL";
      value?: string;
    };
    PagedModelImportFileIssueModel: {
      _embedded?: {
        importFileIssues?: components["schemas"]["ImportFileIssueModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CollectionModelImportNamespaceModel: {
      _embedded?: {
        namespaces?: components["schemas"]["ImportNamespaceModel"][];
      };
    };
    ImportNamespaceModel: {
      /**
       * Format: int64
       * @description The id of namespace. When null, namespace doesn't exist and will be created by import.
       * @example 10000048
       */
      id?: number;
      /** @example homepage */
      name: string;
    };
    CollectionModelBatchJobModel: {
      _embedded?: {
        batchJobs?: components["schemas"]["BatchJobModel"][];
      };
    };
    PagedModelTranslationCommentModel: {
      _embedded?: {
        translationComments?: components["schemas"]["TranslationCommentModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelTranslationHistoryModel: {
      _embedded?: {
        revisions?: components["schemas"]["TranslationHistoryModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    TranslationHistoryModel: {
      /** @description Modified fields */
      modifications?: {
        [key: string]: components["schemas"]["PropertyModification"];
      };
      /**
       * Format: int64
       * @description Unix timestamp of the revision
       */
      timestamp: number;
      author?: components["schemas"]["SimpleUserAccountModel"];
      revisionType: "ADD" | "MOD" | "DEL";
    };
    SelectAllResponse: {
      ids: number[];
    };
    KeyWithTranslationsModel: {
      /**
       * Format: int64
       * @description Id of key record
       */
      keyId: number;
      /**
       * @description Name of key
       * @example this_is_super_key
       */
      keyName: string;
      /**
       * Format: int64
       * @description The namespace id of the key
       * @example 100000282
       */
      keyNamespaceId?: number;
      /**
       * @description The namespace of the key
       * @example homepage
       */
      keyNamespace?: string;
      /** @description Tags of key */
      keyTags: components["schemas"]["TagModel"][];
      /**
       * Format: int64
       * @description Count of screenshots provided for the key
       * @example 1
       */
      screenshotCount: number;
      /** @description Key screenshots. Not provided when API key hasn't screenshots.view scope permission. */
      screenshots?: components["schemas"]["ScreenshotModel"][];
      /** @description There is a context available for this key */
      contextPresent: boolean;
      /**
       * @description Translations object
       * @example
       *     {
       *       "en": {
       *         "id": 100000003,
       *         "text": "This is super translation!"
       *         "state": "TRANSLATED",
       *         "commentCount": 1
       *       }
       *     }
       */
      translations: {
        [key: string]: components["schemas"]["TranslationViewModel"];
      };
    };
    KeysWithTranslationsPageModel: {
      _embedded?: {
        keys?: components["schemas"]["KeyWithTranslationsModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
      /** @description Provided languages data */
      selectedLanguages: components["schemas"]["LanguageModel"][];
      /**
       * @description Cursor to get next data
       * @example eyJrZXlJZCI6eyJkaXJlY3Rpb24iOiJBU0MiLCJ2YWx1ZSI6IjEwMDAwMDAxMjAifX0=
       */
      nextCursor?: string;
    };
    /**
     * @description Translations object
     * @example
     *     {
     *       "en": {
     *         "id": 100000003,
     *         "text": "This is super translation!"
     *         "state": "TRANSLATED",
     *         "commentCount": 1
     *       }
     *     }
     */
    TranslationViewModel: {
      /**
       * Format: int64
       * @description Id of translation record
       */
      id: number;
      /** @description Translation text */
      text?: string;
      /** @description State of translation */
      state: "UNTRANSLATED" | "TRANSLATED" | "REVIEWED" | "DISABLED";
      /** @description Whether base language translation was changed after this translation was updated */
      outdated: boolean;
      /** @description Was translated using Translation Memory or Machine translation service? */
      auto: boolean;
      /** @description Which machine translation service was used to auto translate this */
      mtProvider?: "GOOGLE" | "AWS" | "DEEPL" | "AZURE" | "BAIDU" | "TOLGEE";
      /**
       * Format: int64
       * @description Count of translation comments
       */
      commentCount: number;
      /**
       * Format: int64
       * @description Count of unresolved translation comments
       */
      unresolvedCommentCount: number;
      /** @description Was translation memory used to translate this? */
      fromTranslationMemory: boolean;
    };
    CollectionModelProjectTransferOptionModel: {
      _embedded?: {
        transferOptions?: components["schemas"]["ProjectTransferOptionModel"][];
      };
    };
    ProjectTransferOptionModel: {
      name: string;
      slug: string;
      /** Format: int64 */
      id: number;
    };
    LanguageStatsModel: {
      /** Format: int64 */
      languageId?: number;
      languageTag?: string;
      languageName?: string;
      languageOriginalName?: string;
      languageFlagEmoji?: string;
      /** Format: int64 */
      translatedKeyCount: number;
      /** Format: int64 */
      translatedWordCount: number;
      /** Format: double */
      translatedPercentage: number;
      /** Format: int64 */
      reviewedKeyCount: number;
      /** Format: int64 */
      reviewedWordCount: number;
      /** Format: double */
      reviewedPercentage: number;
      /** Format: int64 */
      untranslatedKeyCount: number;
      /** Format: int64 */
      untranslatedWordCount: number;
      /** Format: double */
      untranslatedPercentage: number;
    };
    ProjectStatsModel: {
      /** Format: int64 */
      projectId: number;
      /** Format: int32 */
      languageCount: number;
      /** Format: int64 */
      keyCount: number;
      /** Format: int64 */
      baseWordsCount: number;
      /** Format: double */
      translatedPercentage: number;
      /** Format: double */
      reviewedPercentage: number;
      /** Format: int64 */
      membersCount: number;
      /** Format: int64 */
      tagCount: number;
      languageStats: components["schemas"]["LanguageStatsModel"][];
    };
    PagedModelLanguageModel: {
      _embedded?: {
        languages?: components["schemas"]["LanguageModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CollectionModelProjectInvitationModel: {
      _embedded?: {
        invitations?: components["schemas"]["ProjectInvitationModel"][];
      };
    };
    Pageable: {
      /** Format: int32 */
      page?: number;
      /** Format: int32 */
      size?: number;
      sort?: string[];
    };
    PagedModelApiKeyModel: {
      _embedded?: {
        apiKeys?: components["schemas"]["ApiKeyModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PagedModelProjectWithStatsModel: {
      _embedded?: {
        projects?: components["schemas"]["ProjectWithStatsModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    ProjectStatistics: {
      /** Format: int64 */
      projectId: number;
      /** Format: int64 */
      keyCount: number;
      /** Format: int64 */
      languageCount: number;
      translationStatePercentages: { [key: string]: number };
    };
    ProjectWithStatsModel: {
      /** Format: int64 */
      id: number;
      name: string;
      description?: string;
      slug?: string;
      avatar?: components["schemas"]["Avatar"];
      organizationOwner?: components["schemas"]["SimpleOrganizationModel"];
      baseLanguage?: components["schemas"]["LanguageModel"];
      organizationRole?: "MEMBER" | "OWNER";
      directPermission?: components["schemas"]["PermissionModel"];
      computedPermission: components["schemas"]["ComputedPermissionModel"];
      stats: components["schemas"]["ProjectStatistics"];
      languages: components["schemas"]["LanguageModel"][];
    };
    CollectionModelScreenshotModel: {
      _embedded?: {
        screenshots?: components["schemas"]["ScreenshotModel"][];
      };
    };
    PagedModelPatModel: {
      _embedded?: {
        pats?: components["schemas"]["PatModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    PatWithUserModel: {
      user: components["schemas"]["SimpleUserAccountModel"];
      /** Format: int64 */
      id: number;
      description: string;
      /** Format: int64 */
      lastUsedAt?: number;
      /** Format: int64 */
      expiresAt?: number;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
    };
    OrganizationRequestParamsDto: {
      filterCurrentUserOwner: boolean;
      search?: string;
    };
    PagedModelOrganizationModel: {
      _embedded?: {
        organizations?: components["schemas"]["OrganizationModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    CollectionModelOrganizationInvitationModel: {
      _embedded?: {
        organizationInvitations?: components["schemas"]["OrganizationInvitationModel"][];
      };
    };
    PublicUsageModel: {
      /** Format: int64 */
      organizationId: number;
      /**
       * Format: int64
       * @description Current balance of standard credits. Standard credits are refilled every month
       */
      creditBalance: number;
      /**
       * Format: int64
       * @description How many credits are included in your current plan
       */
      includedMtCredits: number;
      /**
       * Format: int64
       * @description Date when credits were refilled. (In epoch format)
       */
      creditBalanceRefilledAt: number;
      /**
       * Format: int64
       * @description Date when credits will be refilled. (In epoch format)
       */
      creditBalanceNextRefillAt: number;
      /**
       * Format: int64
       * @description Currently used credits over credits included in plan and extra credits
       */
      currentPayAsYouGoMtCredits: number;
      /**
       * Format: int64
       * @description The maximum amount organization can spend on MT credit usage before they reach the spending limit
       */
      availablePayAsYouGoMtCredits: number;
      /**
       * Format: int64
       * @description Extra credits, which are neither refilled nor reset every month. These credits are used when there are no standard credits
       */
      extraCreditBalance: number;
      /**
       * Format: int64
       * @description How many translations can be stored within your organization
       */
      translationSlotsLimit: number;
      /**
       * Format: int64
       * @description How many translation slots are included in current subscription plan. How many translation slots can organization use without additional costs
       */
      includedTranslationSlots: number;
      /**
       * Format: int64
       * @description How many translations are included in current subscription plan. How many translations can organization use without additional costs
       */
      includedTranslations: number;
      /**
       * Format: int64
       * @description How many translations slots are currently used by organization
       */
      currentTranslationSlots: number;
      /**
       * Format: int64
       * @description How many non-empty translations are currently stored by organization
       */
      currentTranslations: number;
      /**
       * Format: int64
       * @description How many translations can be stored until reaching the limit. (For pay us you go, the top limit is the spending limit)
       */
      translationsLimit: number;
    };
    PagedModelUserAccountWithOrganizationRoleModel: {
      _embedded?: {
        usersInOrganization?: components["schemas"]["UserAccountWithOrganizationRoleModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    SimpleProjectModel: {
      /** Format: int64 */
      id: number;
      name: string;
      description?: string;
      slug?: string;
      avatar?: components["schemas"]["Avatar"];
      baseLanguage?: components["schemas"]["LanguageModel"];
    };
    UserAccountWithOrganizationRoleModel: {
      /** Format: int64 */
      id: number;
      name: string;
      username: string;
      organizationRole?: "MEMBER" | "OWNER";
      projectsWithDirectPermission: components["schemas"]["SimpleProjectModel"][];
      avatar?: components["schemas"]["Avatar"];
    };
    ApiKeyWithLanguagesModel: {
      /**
       * @deprecated
       * @description Languages for which user has translate permission.
       */
      permittedLanguageIds?: number[];
      /** Format: int64 */
      id: number;
      projectName: string;
      userFullName?: string;
      username?: string;
      description: string;
      /** Format: int64 */
      lastUsedAt?: number;
      /** Format: int64 */
      expiresAt?: number;
      /** Format: int64 */
      projectId: number;
      scopes: string[];
    };
    ApiKeyPermissionsModel: {
      /**
       * Format: int64
       * @description The API key's project id or the one provided as query param
       */
      projectId: number;
      /**
       * @description List of languages user can view. If null, all languages view is permitted.
       * @example 200001,200004
       */
      viewLanguageIds?: number[];
      /**
       * @description List of languages user can translate to. If null, all languages editing is permitted.
       * @example 200001,200004
       */
      translateLanguageIds?: number[];
      /**
       * @description List of languages user can change state to. If null, changing state of all language values is permitted.
       * @example 200001,200004
       */
      stateChangeLanguageIds?: number[];
      /**
       * @description Granted scopes to the user. When user has type permissions, this field contains permission scopes of the type.
       * @example KEYS_EDIT,TRANSLATIONS_VIEW
       */
      scopes: (
        | "translations.view"
        | "translations.edit"
        | "keys.edit"
        | "screenshots.upload"
        | "screenshots.delete"
        | "screenshots.view"
        | "activity.view"
        | "languages.edit"
        | "admin"
        | "project.edit"
        | "members.view"
        | "members.edit"
        | "translation-comments.add"
        | "translation-comments.edit"
        | "translation-comments.set-state"
        | "translations.state-edit"
        | "keys.view"
        | "keys.delete"
        | "keys.create"
        | "batch-jobs.view"
        | "batch-jobs.cancel"
        | "translations.batch-by-tm"
        | "translations.batch-machine"
        | "content-delivery.manage"
        | "content-delivery.publish"
        | "webhooks.manage"
      )[];
      /** @description The user's permission type. This field is null if user has assigned granular permissions or if returning API key's permissions */
      type?: "NONE" | "VIEW" | "TRANSLATE" | "REVIEW" | "EDIT" | "MANAGE";
    };
    PagedModelUserAccountModel: {
      _embedded?: {
        users?: components["schemas"]["UserAccountModel"][];
      };
      page?: components["schemas"]["PageMetadata"];
    };
    UserAccountModel: {
      /** Format: int64 */
      id: number;
      username: string;
      name?: string;
      emailAwaitingVerification?: string;
      avatar?: components["schemas"]["Avatar"];
      globalServerRole: "USER" | "ADMIN";
      deleted: boolean;
      disabled: boolean;
    };
    UserTotpDisableRequestDto: {
      password: string;
    };
    DeleteKeysDto: {
      /** @description IDs of keys to delete */
      ids: number[];
    };
    Link: {
      href?: string;
      hreflang?: string;
      title?: string;
      type?: string;
      deprecation?: string;
      profile?: string;
      name?: string;
      templated?: boolean;
    };
  };
}

export interface operations {
  getInfo_2: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PrivateUserAccountModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  update_2: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["NamespaceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateNamespaceDto"];
      };
    };
  };
  getDisabledLanguages_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelLanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  setDisabledLanguages_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelLanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetDisabledLanguagesRequest"];
      };
    };
  };
  complexEdit_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["KeyWithDataModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ComplexEditKeyDto"];
      };
    };
  };
  edit_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["KeyModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EditKeyDto"];
      };
    };
  };
  tagKey_1: {
    parameters: {
      path: {
        keyId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TagModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagKeyDto"];
      };
    };
  };
  /** Resolves translation conflict. The old translation will be overridden. */
  resolveTranslationSetOverride_1: {
    parameters: {
      path: {
        languageId: number;
        translationId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Resolves translation conflict. The old translation will be kept. */
  resolveTranslationSetKeepExisting_1: {
    parameters: {
      path: {
        languageId: number;
        translationId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Resolves all translation conflicts for provided language. The old translations will be overridden. */
  resolveTranslationSetOverride_3: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Resolves all translation conflicts for provided language. The old translations will be kept. */
  resolveTranslationSetKeepExisting_3: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Sets existing language to pair with language to import. Data will be imported to selected existing language when applied. */
  selectExistingLanguage_1: {
    parameters: {
      path: {
        importLanguageId: number;
        existingLanguageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Resets existing language paired with language to import. */
  resetExistingLanguage_1: {
    parameters: {
      path: {
        importLanguageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Sets namespace for file to import. */
  selectNamespace_1: {
    parameters: {
      path: {
        fileId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetFileNamespaceRequest"];
      };
    };
  };
  /** Imports the data prepared in previous step */
  applyImport_1: {
    parameters: {
      query: {
        /** Whether override or keep all translations with unresolved conflicts */
        forceMode?: "OVERRIDE" | "KEEP" | "NO_FORCE";
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  cancel_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  setTranslationState_1: {
    parameters: {
      path: {
        translationId: number;
        state: "TRANSLATED" | "REVIEWED";
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  setState_1: {
    parameters: {
      path: {
        commentId: number;
        state: "RESOLUTION_NOT_NEEDED" | "NEEDS_RESOLUTION" | "RESOLVED";
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  get_10: {
    parameters: {
      path: {
        translationId: number;
        commentId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  update_6: {
    parameters: {
      path: {
        commentId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TranslationCommentDto"];
      };
    };
  };
  delete_9: {
    parameters: {
      path: {
        commentId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  setOutdated_1: {
    parameters: {
      path: {
        translationId: number;
        state: boolean;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  dismissAutoTranslatedState_1: {
    parameters: {
      path: {
        translationId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["TranslationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getTranslations_1: {
    parameters: {
      query: {
        /** Cursor to get next data */
        cursor?: string;
        /**
         * Translation state in the format: languageTag,state. You can use this parameter multiple times.
         *
         * When used with multiple states for same language it is applied with logical OR.
         *
         * When used with multiple languages, it is applied with logical AND.
         */
        filterState?: string[];
        /**
         * Languages to be contained in response.
         *
         * To add multiple languages, repeat this param (eg. ?languages=en&languages=de)
         */
        languages?: string[];
        /** String to search in key name or translation text */
        search?: string;
        /** Selects key with provided names. Use this param multiple times to fetch more keys. */
        filterKeyName?: string[];
        /** Selects key with provided ID. Use this param multiple times to fetch more keys. */
        filterKeyId?: number[];
        /** Selects only keys, where translation is missing in any language */
        filterUntranslatedAny?: boolean;
        /** Selects only keys, where translation is provided in any language */
        filterTranslatedAny?: boolean;
        /** Selects only keys, where translation is missing in specified language */
        filterUntranslatedInLang?: string;
        /** Selects only keys, where translation is provided in specified language */
        filterTranslatedInLang?: string;
        /** Selects only keys with screenshots */
        filterHasScreenshot?: boolean;
        /** Selects only keys without screenshots */
        filterHasNoScreenshot?: boolean;
        /**
         * Filter namespaces.
         *
         * To filter default namespace, set to empty string.
         */
        filterNamespace?: string[];
        /** Selects only keys with provided tag */
        filterTag?: string[];
        /** Selects only keys, where translation in provided langs is in outdated state */
        filterOutdatedLanguage?: string[];
        /** Selects only keys, where translation in provided langs is not in outdated state */
        filterNotOutdatedLanguage?: string[];
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["KeysWithTranslationsPageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  setTranslations_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["SetTranslationsResponseModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetTranslationsWithKeyDto"];
      };
    };
  };
  createOrUpdateTranslations_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["SetTranslationsResponseModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetTranslationsWithKeyDto"];
      };
    };
  };
  get_12: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["LanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  editLanguage_1: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["LanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LanguageDto"];
      };
    };
  };
  deleteLanguage_3: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /**
   * Uses enabled auto-translation methods.
   * You need to set at least one of useMachineTranslation or useTranslationMemory to true.
   *
   * This will replace the the existing translation with the result obtained from specified source!
   */
  autoTranslate_1: {
    parameters: {
      path: {
        keyId: number;
      };
      query: {
        /**
         * Tags of languages to auto-translate.
         * When no languages provided, it translates only untranslated languages.
         */
        languages?: string[];
        useMachineTranslation?: boolean;
        useTranslationMemory?: boolean;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  get_15: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["OrganizationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getAll: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        search?: string;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/hal+json": components["schemas"]["PagedModelProjectModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  createProject: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["ProjectModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateProjectDTO"];
      };
    };
  };
  getInfo_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelKeyWithDataModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetKeysRequestDto"];
      };
    };
  };
  importKeys_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["KeyImportResolvableResultModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ImportKeysResolvableDto"];
      };
    };
  };
  importKeys_3: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ImportKeysDto"];
      };
    };
  };
  create_3: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["KeyWithDataModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateKeyDto"];
      };
    };
  };
  getAll_2: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelKeyModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  create_4: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["KeyWithDataModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateKeyDto"];
      };
    };
  };
  delete_5: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteKeysDto"];
      };
    };
  };
  untagKeys_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UntagKeysRequest"];
      };
    };
  };
  tagKeys_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TagKeysRequest"];
      };
    };
  };
  setTranslationState_3: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetTranslationsStateStateRequest"];
      };
    };
  };
  setKeysNamespace_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetKeysNamespaceRequest"];
      };
    };
  };
  /** Pre-translate provided keys to provided languages by TM. */
  translate_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PreTranslationByTmRequest"];
      };
    };
  };
  /** Translate provided keys to provided languages through primary MT provider. */
  machineTranslation_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["MachineTranslationRequest"];
      };
    };
  };
  deleteKeys_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeleteKeysRequest"];
      };
    };
  };
  /** Copy translation values from one language to other languages. */
  copyTranslations_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CopyTranslationRequest"];
      };
    };
  };
  /** Clear translation values for provided keys in selected languages. */
  clearTranslations_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ClearTranslationsRequest"];
      };
    };
  };
  /** Prepares provided files to import. */
  addFiles_1: {
    parameters: {
      query: {
        /** When importing structured JSONs, you can set the delimiter which will be used in names of improted keys. */
        structureDelimiter?: string;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["ImportAddFilesResultModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          files: string[];
        };
      };
    };
  };
  /** Deletes prepared import data. */
  cancelImport_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  export_1: {
    parameters: {
      query: {
        /**
         * Languages to be contained in export.
         *
         * If null, all languages are exported
         */
        languages?: string[];
        /** Format to export to */
        format?: "JSON" | "XLIFF";
        /**
         * Delimiter to structure file content.
         *
         * e.g. For key "home.header.title" would result in {"home": {"header": "title": {"Hello"}}} structure.
         *
         * When null, resulting file won't be structured.
         */
        structureDelimiter?: string;
        /** Filter key IDs to be contained in export */
        filterKeyId?: number[];
        /** Filter key IDs not to be contained in export */
        filterKeyIdNot?: number[];
        /** Filter keys tagged by */
        filterTag?: string;
        /** Filter keys with prefix */
        filterKeyPrefix?: string;
        /** Filter translations with state. By default, everything except untranslated is exported. */
        filterState?: (
          | "UNTRANSLATED"
          | "TRANSLATED"
          | "REVIEWED"
          | "DISABLED"
        )[];
        /** Select one ore multiple namespaces to export */
        filterNamespace?: string[];
        /**
         * If false, it doesn't return zip of files, but it returns single file.
         *
         * This is possible only when single language is exported. Otherwise it returns "400 - Bad Request" response.
         */
        zip?: boolean;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["StreamingResponseBody"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  exportPost_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["StreamingResponseBody"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportParams"];
      };
    };
  };
  store_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["BigMetaDto"];
      };
    };
  };
  getAll_6: {
    parameters: {
      path: {
        translationId: number;
      };
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelTranslationCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  create_8: {
    parameters: {
      path: {
        translationId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["TranslationCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TranslationCommentDto"];
      };
    };
  };
  create_10: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["TranslationWithCommentModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TranslationCommentWithLangKeyDto"];
      };
    };
  };
  suggestTranslationMemory_1: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelTranslationMemoryItemModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SuggestRequestDto"];
      };
    };
  };
  suggestMachineTranslationsStreaming_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/x-ndjson": components["schemas"]["StreamingResponseBody"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SuggestRequestDto"];
      };
    };
  };
  suggestMachineTranslations_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["SuggestResultModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SuggestRequestDto"];
      };
    };
  };
  getAll_8: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelLanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  createLanguage_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["LanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["LanguageDto"];
      };
    };
  };
  getKeyScreenshots: {
    parameters: {
      path: {
        keyId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelScreenshotModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  uploadScreenshot: {
    parameters: {
      path: {
        keyId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["ScreenshotModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          screenshot: string;
          info?: components["schemas"]["ScreenshotInfoDto"];
        };
      };
    };
  };
  getAll_10: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        params: components["schemas"]["OrganizationRequestParamsDto"];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/hal+json": components["schemas"]["PagedModelOrganizationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  create_12: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["OrganizationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["OrganizationDto"];
      };
    };
  };
  upload: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** Created */
      201: {
        content: {
          "*/*": components["schemas"]["UploadedImageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /** Format: binary */
          image: string;
          info?: components["schemas"]["ImageUploadInfoDto"];
        };
      };
    };
  };
  getUsedNamespaces_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelUsedNamespaceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getAllNamespaces_1: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelNamespaceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getByName_1: {
    parameters: {
      path: {
        name: string;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["NamespaceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  searchForKey_1: {
    parameters: {
      query: {
        /** Search query */
        search: string;
        /** Language to search in */
        languageTag?: string;
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelKeySearchSearchResultModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getActivity_1: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/hal+json": components["schemas"]["PagedModelProjectActivityModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getAll_4: {
    parameters: {
      query: {
        search?: string;
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelTagModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  myList_1: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelBatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getBigMeta_1: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelKeyWithBaseTranslationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Returns translations prepared to import. */
  getImportTranslations_1: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** Whether only translations, which are in conflict with existing translations should be returned */
        onlyConflicts?: boolean;
        /** Whether only translations with unresolved conflictswith existing translations should be returned */
        onlyUnresolved?: boolean;
        /** String to search in translation text or key */
        search?: string;
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelImportTranslationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Returns language prepared to import. */
  getImportLanguage_1: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["ImportLanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Deletes language prepared to import. */
  deleteLanguage_1: {
    parameters: {
      path: {
        languageId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Returns issues for uploaded file. */
  getImportFileIssues_1: {
    parameters: {
      path: {
        importFileId: number;
      };
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelImportFileIssueModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Returns the result of preparation. */
  getImportResult_1: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelImportLanguageModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Returns all existing and imported namespaces */
  getAllNamespaces_3: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelImportNamespaceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  /** Completed batch operations are returned only if they are not older than 1 hour. If user doesn't have permission to view all batch operations, only their operations are returned. */
  currentJobs_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CollectionModelBatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  get_8: {
    parameters: {
      path: {
        id: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["BatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  list_4: {
    parameters: {
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelBatchJobModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getTranslationHistory_1: {
    parameters: {
      path: {
        translationId: number;
      };
      query: {
        /** Zero-based page index (0..N) */
        page?: number;
        /** The size of the page to be returned */
        size?: number;
        /** Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
        sort?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PagedModelTranslationHistoryModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getAllTranslations_1: {
    parameters: {
      path: {
        /** Comma-separated language tags to return translations in. Languages you are not permitted to see will be silently dropped and not returned. */
        languages: string[];
      };
      query: {
        /** Namespace to return */
        ns?: string;
        /**
         * Delimiter to structure response content.
         *
         * e.g. For key "home.header.title" would result in {"home": {"header": {"title": "Hello"}}} structure.
         *
         * When null, resulting file will be a flat key-value object.
         */
        structureDelimiter?: string;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": string;
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getSelectAllKeyIds_1: {
    parameters: {
      query: {
        /**
         * Translation state in the format: languageTag,state. You can use this parameter multiple times.
         *
         * When used with multiple states for same language it is applied with logical OR.
         *
         * When used with multiple languages, it is applied with logical AND.
         */
        filterState?: string[];
        /**
         * Languages to be contained in response.
         *
         * To add multiple languages, repeat this param (eg. ?languages=en&languages=de)
         */
        languages?: string[];
        /** String to search in key name or translation text */
        search?: string;
        /** Selects key with provided names. Use this param multiple times to fetch more keys. */
        filterKeyName?: string[];
        /** Selects key with provided ID. Use this param multiple times to fetch more keys. */
        filterKeyId?: number[];
        /** Selects only keys, where translation is missing in any language */
        filterUntranslatedAny?: boolean;
        /** Selects only keys, where translation is provided in any language */
        filterTranslatedAny?: boolean;
        /** Selects only keys, where translation is missing in specified language */
        filterUntranslatedInLang?: string;
        /** Selects only keys, where translation is provided in specified language */
        filterTranslatedInLang?: string;
        /** Selects only keys with screenshots */
        filterHasScreenshot?: boolean;
        /** Selects only keys without screenshots */
        filterHasNoScreenshot?: boolean;
        /**
         * Filter namespaces.
         *
         * To filter default namespace, set to empty string.
         */
        filterNamespace?: string[];
        /** Selects only keys with provided tag */
        filterTag?: string[];
        /** Selects only keys, where translation in provided langs is in outdated state */
        filterOutdatedLanguage?: string[];
        /** Selects only keys, where translation in provided langs is not in outdated state */
        filterNotOutdatedLanguage?: string[];
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["SelectAllResponse"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getProjectDailyActivity_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/hal+json": { [key: string]: number };
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getProjectStats_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/hal+json": components["schemas"]["ProjectStatsModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getCurrent: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["PatWithUserModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  get_14: {
    parameters: {
      path: {
        slug: string;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["OrganizationModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getOrganizationCredits: {
    parameters: {
      path: {
        organizationId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["CreditBalanceModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getCurrent_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["ApiKeyWithLanguagesModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  getCurrentPermissions: {
    parameters: {
      query: {
        /** Required when using with PAT */
        projectId?: number;
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "*/*": components["schemas"]["ApiKeyPermissionsModel"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  doExportJsonZip_1: {
    parameters: {
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/zip": components["schemas"]["StreamingResponseBody"];
        };
      };
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  delete_3: {
    parameters: {
      path: {
        ids: number[];
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  removeTag_1: {
    parameters: {
      path: {
        keyId: number;
        tagId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  deleteScreenshots: {
    parameters: {
      path: {
        ids: number[];
        keyId: number;
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
  delete_12: {
    parameters: {
      path: {
        ids: number[];
      };
      query: {
        /** API key provided via query parameter. Will be deprecated in the future. */
        ak?: string;
      };
      header: {
        /** API key provided via header. Safer since headers are not stored in server logs. */
        "X-API-Key"?: string;
      };
    };
    responses: {
      /** OK */
      200: unknown;
      /** Bad Request */
      400: {
        content: {
          "*/*": string;
        };
      };
      /** Not Found */
      404: {
        content: {
          "*/*": string;
        };
      };
    };
  };
}

export interface external {}
